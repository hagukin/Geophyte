20200320? - 파이썬 입문




< AsciiArena / Geophyte ver1, 2, 3 >
>> 절차지향 스타일 코드로 작성됨. (클래스, 메소드 사용 X, .py파일 하나에 모든 코드를 작성.) <<

20200408 - 로그라이크 개발 시작. 게임 기획.
20200409 - 기반이 되는 코드들 작성.
20200410 - 밀리 공격 시스템 제작. 데미지 계산 가능. 아직 유닛이 파괴되어 사라지는 건 구현하지 못함.
20200411 - 그래픽 출력 버그 수정, 데미지 계산 후 파괴  기능 구현. 버그 발견 -> DB에 저장한 체력값에 더하고 빼는 식으로 체력계산을 하는데, 이렇게 되면 같은 종류의 유닛이 여러개 있을 경우 하나만 파괴되도 유닛 전체가 사라지는 문제가 발생함.
            클래스 사용해서 버그 픽스하면 문제점이 많아서 copy 모듈을 사용해 DB에서 스텟값만 유닛에게 복사하는 방식으로 버그 수정함.
            로그 시스템 추가.
            아이템 시스템 추가. 아직 아이템 픽업 시스템은 구현하지 못함.
            이펙트 시스템 추가. (힐링)  아직 최대 체력 시스템은 구현하지 못해 힐 = 체력 스텟 증가로 작동함. (최대체력 값은 존재하지만 최대체력을 넘어선다고 제약이 걸리지 않음)
            아이템 프린팅 시스템 추가.
            유닛, 아이템 인스턴스들 기존 리스트 자료형에서 전부 딕셔너리 자료형으로 변경완료. AsciiArena_ver2로 파일 변경.
            아이템 픽업 시스템 추가. 인벤토리 최대 무게를 넘어선다면 burden 걸리게 하는 거 추가 예정.
            게임오버 시스템 추가.
            죽인 적 수 표시 추가 예정.
            타일 하나에 여러 개 아이템 떨어져 있을 때 픽업 기능 추가. 아이템 픽업 GUI 추가.
            410번 라인에 버그있는데 이유를 모르겠음. 아이템 두개 중 하나만 픽업할 때는 정상작동함.
20200412 - 410번 라인 (아이템 픽업 그리드 삭제) 버그 픽스 완료
            아이템 드랍 시스템 추가.
            AI 종류 기획.
            땅 아스키 그래픽 마침표에서 중앙 점으로 변경, 벽 |와 _ 에서 #으로 변경.
            AI 시스템 추가, random AI 제작.
            8 ways move 추가.
            hostile_mad, friendly_mad AI 제작. 해당 AI가 자기 자신을 타켓팅한 후 움직이지 않는 버그 수정.
            시간, 스피드 시스템 추가. 큰 변화이므로 AsciiArena_ver3로 파일 변경.
20200413 - 더 나아진 GUI. GUI에 인게임 시간 흐름 추가.
            이제 인벤토리 내에서 액션을 취할 아이템을 선택할 수 있음.
            잘못된 커맨드를 입력하거나, 인벤토리를 켜서 아이템만 확인하고 끄는 경우에도 인게임 시간이 흐르는 문제를 해결. (timepass 를 통해 인게임 내 시간의 흐름 여부를 조절가능해짐.)
            일부 아이템과 몬스터들 기획.
20200414 - 인벤토리에서 drop 시스템 완성
            스테이터스 창 기초 구조 작성
20200415 - 인벤토리 등을 열 때 열기만 하는것으로 ingame time이 30 지나가버리는 버그 해결.
            적들의 스피드가 플레이어보다 빨라 플레이어가 입력하기 전에 플레이어를 죽였을 때 적들의 self_time이 무한정 오르면서 게임이 끝나지 않는 버그 해결.
            인게임 GUI에 인게임 시간 표시.
            스테이터스 창 완성.
            제목 : Geophyte 로 변경 (ver1)
            게임 오버 이후 로그확인 기능 추가
20200418 - 그래픽(색상) 적용 시도, 실패
20200420   카메라 시스템 추가.
            액션 시스템 함수 형태로 추가. 체력포션 테스트용으로 추가.
            Geophyte_ver2 로 변경.
20200421 - 원거리 공격 시스템 초기 구조 작성.
            유닛들에게 주,부무기와 장비 변수 추가.
            일부 무기들에게 ammo_type 추가.
            ammo를 소모하는 시스템 초기 구조 작성.
            원거리 공격 버그픽스 필요. 발사체가 날아가면서 최초로 부딪히는 벽을 찾기 위한 for문의 중첩 과정에서 원인 불명의 에러 발생.
            fire 이후 함수 처리순서 : action_calculation >> fire_weapon >> ranged_atk(버그1) >> ranged_animation(버그2)
20200422 - 원거리 공격의 데미지 처리는 구현했음.
            그러나 linear animation 출력 시 버그 존재 1) 궤적이 애니메이션 출력 후에도 계속 남아있는 버그 2) 애니메이션 출력 시 몬스터가 보이지 않는 버그
20200425 - 특정 방향으로 쏠때 linear animation 출력 안되는 버그 수정
            아이템 드랍을 인벤토리 내에서 할 때 오류 생기는 문제 해결. (완전히 해결 됐는지는 불확실함)
            원거리 공격 궤적이 애니메이션 출력 후에도 계속 남아있는 버그 해결.
            linear 애니메이션 출력 시 몬스터가 보이지 않는 버그도 해결.
20200428 - pathfinding 시스템(A* 알고리즘)과, 보다 정교한 AI 작성중.
            pathfinding 시스템 거의 작성 완료. 이제 closed된 node들 중에서 최단경로로 선택한 노드들만 남기기만 하면 됨.
            pathfinding 시스템이 벽이 있을 때 비정상적으로 동작하는 버그 수정.
            Geophyte_ver3로 변경.



< Geophyte_ver4 개발일지 >
>> 객체지향 구조를 사용해서 만든 로그라이크. <<

2020 07 03 - OOP 구조로 geophyte ver4 작업 개시. 
            던전 랜덤 제너레이팅 시스템 초기 구조 작성. 
            아이템 랜덤 스폰 구조 작성.
2020 07 04 - room 별 지형 부여 및 지형 제너레이팅 시스템 작성.
            랜덤 시드 시스템 사용하는법 : 모든 random.method() 구문 바로 윗줄에 random.seed(시드값) 을 넣어주면 됨. (한번만 써도 되나?)
            몬스터, 아이템 위치 랜덤제너레이팅 이후 구체적으로 개체를 지정하는 시스템 작성.
            컬러 텍스트 시스템 도입.
2020 07 05 - 지형 생성 (풀숲, 물웅덩이) 시스템 구축.
            기존 region 생성 시스템에 있던 버그들 대거 수정.
            search_nearby_tile이 기존에는 room_core의 순서를 입력받던 것에서 아무 좌표값이나 입력받는 걸로 변경함.
            search_nearby_tile에 있었던 다량의 버그 수정.
            item_grid_data 추가.
2020 07 06 - collision 시스템 구축.
            플레이어.py 추가
            플레이어 입력 시스템 추가
            플레이어 이동 시스템 추가
            플레이어 이동 그래픽 출력 기능 작성
            그래픽 출력의 레이어화 (layer) 완료
            player_grid_data 추가
            기존 그래픽을 그리드에 직접 추가하는 형태에서부터 grid_data에서 데이터를 받아 그리드에 존재하는 유닛들을 출력하는 형태로 변경함.
2020 07 07 - 카메라 시스템 구축
            몬스터와 아이템을 스폰할 때 각 인스턴스 별로 스텟 변경 등을 개별적으로 할 수 있게끔 제작. (geophyte_ver3까지는 제작하지 못했던 기능)
            (멀티플레이어 대비) 플레이어 인스턴스가 여러 개일때도 작동 가능하게 변경.
            즉 같은 종류의 아이템들중 한 개의 아이템만을 강화하거나 몬스터 한 마리의 스텟만을 약화시키거나 와 같은 행동들이 가능해짐.
            각 유닛 별 속도(speed)를 부여하고, 속도를 통해 인게임 내 액션을 실행할 수 있는 빈도가 달라지는 시스템 구현.
            층 생성 시스템 구축
            플레이어의 층간 이동 시스템 구축
            층이 많아질때 속도가 급격하게 낮아지는 현상 해결
            현재 주석, txt포함 2005줄
            계단은 무조건 room tile에서만 생성되도록 변경.
2020 07 08 - 자료구조 queue를 도입을 통한 성능 향상 계획 수립
            a star 알고리즘을 통한 길찾기 부분 도입, 아직 성공적이지 못함.
2020 07 09 - astar 알고리즘 보안해서 적용, 그러나 속도가 느리고 버그 있음.
            bfs 알고리즘으로 교체해보았으나 마찬가지로 속도 느리고 버그 있음.




< Geophyte_tcod 개발일지 >
>> 객체지향으로 작성, ECS와 component-based 구조를 사용하며 tcod 모듈을 사용한 로그라이크 개발. <<

20200713? - (TCOD) tcod를 이용해 콘솔창 표시, 타일셋 그래픽으로 렌더링, 플레이어의 4방향 이동 기능 추가.
20200714? - (TCOD) ECS에 맞게 기반이 되는 엔티티 제작.
            (TCOD) engine.py 제작.
20200715? - (TCOD) 기초적인 Procedural Generation 시스템 제작.
20200716? - (TCOD) numPy를 이용해 타일 데이터타입 제작.
            (TCOD) 타일 데이터 및 타일 색상 데이터를 저장하는 tile_types.py 추가.
            (TCOD) Field of View 연산 처리 기능 및 FOV에 따라 타일 렌더링 색상이 변경되는 기능 추가.
20200717? - (TCOD) 플레이어의 공격(데미지 연산은 아직 처리되지 않음) 기능 추가.
            (TCOD) 던전 내 몬스터를 무작위로 배치하는 기능 추가.
            (TCOD) 몬스터들에게 Ai 부여, 기초적인 pathfinding 기능 추가.
            (TCOD) 기존 4방향 이동에서 8방향 이동으로 확대. 이동 관련 인풋을 받는 시스템을 개선.
20200718? - (TCOD) Fighter 컴포넌트 추가. 전투와 관련된 기능을 담당함. 본 게임은 ECS(Entity Component System)를 사용함.
            (TCOD) 아주 간단한 데미지 계산 기능 추가함
            (TCOD) AI의 밀리 공격 기능 추가
            (TCOD) 엔티티의 사망 기능 추가
20200719? - (TCOD) 체력 GUI 추가
            (TCOD) 로그 창 추가, 로그별 글씨 색 추가, 로그 창 스크롤 기능 추가
	        (TCOD) 전체적인 그래픽 변경.
20200720? - (TCOD) 스크롤 세 종류 추가 >> 1) 범위 공격 논타겟 스크롤, 2) 자유 타겟팅 스크롤, 3) 오토 타겟팅 스크롤
            (TCOD) 인벤토리 컴포넌트 추가.
            (TCOD) 아이템 드랍 기능 추가.
20200729 - ray type 인풋받고 그래픽 출력하는 기능, 연산하는 기능 추가.
            procedural generation의 방들 간 충돌 확인을 조금 더 정밀하게 바꿈. 이제 직사각형 이외 모양의 방들을 만들 수 있음.
	        사운드 기능 추가. 아직 시험적으로만 사용중임.
20200730,31 - Dungeon Generation 대폭 개선 : 
                1. 기존 bresenham line으로 직선으로 잇는 방법에서 pathfinding을 통한 터널 생성
                2. 다양한 형태의 방 추가. 이 과정에서 방 내부의 타일들의 좌표를 계산하는 기능을 새로 작성함. (기존 사각형 방의 경우 타일들의 좌표를 구하는 게 굉장히 쉬웠는데, 방의 형태가 다양해 지면서 보다 유연한 해결방법이 필요해짐.)
                3. 문 생성 시스템 추가. 여러 시행착오를 거친 끝에, 방과 방의 collision을 체크하는 방식을, 단순히 사각형이 겹치는 지 확인하는 방법으로는 부족하다고 판단함. 따라서 방 간의 collision check 방식을 각 방들의 타일 리스트를 구해 해당 리스트에 겹치는 요소가 하나라도 있는지 확인하는 방식으로 수정함.
                4. 터널이 방 경계에 충돌하는 버그 해결. 또한 맵 전체의 가장 외곽 테두리는 항상 Wall로 남겨둠으로써 맵 경계와 터널이 충돌하지 않도록 조치함.
                tilemap 추가. 실제 게임 맵과는 별도의 용도로 사용하는 numpy 2darray 데이터임.
20200801 - door open, close 기능 추가. 각각의 경우 사용할 그래픽 정보 추가.
            일부 상황에서 방에 문이 생성이 안되어 플레이어가 갇히는 버그 수정.
            scroll of magic mapping 추가
            다양한 형태의 방들이 던전에 일정 확률로 스폰되는 기능 추가.
20200802 - Ai가 문을 열고 추격할 수 있게 개선.
            문을 열거나 닫을 때 일정 확률로 실패할 수 있게 변경.
20200803? - 차후 인게임 그래픽에 사용할 아스키 아트를 생성할 수 있는 Ascii-fier을 별도의 프로젝트로 제작.
20200805 - 엔티티에게 id, rarity, spawnable이라는 인자 추가. 
            각종 엔티티들과 consumable.py 내 클래스들의 호칭 변경.
            procgen에서 기존 랜덤으로 소환되는 엔티티 스폰 시스템 수정 -> rarity와 spawnable에 따라 던전에 스폰될 확률이 결정되는 엔티티 스폰 시스템으로 변경.
            시체의 render order을 아이템의 render order와 통합.
            기존 아이템이 중첩되어있을 때 순서가 섞여 렌더링되거나, 순서는 잘 렌더링되지만 막상 픽업을 하면 이상한 순서로 픽업된다거나, 혹은 순서도 렌더링 잘 되고 픽업도 잘 되지만 픽업하고 난 후에도 그래픽이 변하지 않는 등 각종 렌더링, 픽업 관련 문제를 종합적으로 해결함.
            윗 줄 버그 해결과 관련해서, game_map.entity를 set가 아닌 list로 관리하는 것으로 변경함. (TODO : OrderedSet 사용 고려해볼것)
            윗 줄 버그 해결과 관련해서, 모든 엔티티에게 render_order 이외에 entity_order라는 값을 부여함으로서 종류별 렌더링도 처리하지만 같은 종류일 때 순서대로 픽업되고 렌더링되는 기능도 추가함.
20200808 - scroll of magic mapping 관련된 버그 수정 >> 1) 사용 후 턴이 넘어가지 않고 플레이어가 또 한번 액션을 취할 수 있던 버그 2) 사용 후 맵 전체의 몬스터들이 플레이어의 위치를 파악하고 쫓아오는 버그
            consume.py를 분리함. readable.py와 quaffable.py 추가.
            인벤토리에서 아이템을 선택하면 바로 consume되는 기존 방식에서, 아이템을 선택하고 그 후 액션을 선택하는 방식으로 변경함.
            다양한 사인마다 표시되는 메세지가 달라지는 시스템 추가.
            액터 엔티티들에게 각종 디테일한 스테이터스 추가. fighter.py 를 status.py로 변경.
            인벤토리 내에서 아이템 선택 후 드랍을 선택할 경우 렌더링에 에러가 나는 버그 수정.
            카메라 시스템 추가를 고려했으나, scroll of magic mapping 사용 시 발생하는 불편함을 우려하여 보류.
            한글 번역을 추가할 방법을 찾았으나, 게임이 완전히 자리잡기 전까지 보류하기로 결정.
	        (기타) 차후 멀티플레이 개발에 활용할 수 있는 socket programming 관련 소규모 프로젝트 제작.
20200809 - 인벤토리 Gui 전반적인 리워크 (위치, 색상)
            엔티티들에게 entity_desc추가, 인벤토리에서 아이템 선택시 desc 출력되는 기능 추가.
            render_order.py를 order.py로 변경, 앞으로 해당 파일은 렌더링 뿐만 아니라 각종 enum들을 관리하는데 사용될 것임.
            order.py에 InventoryOrder라는 enum 추가. 인벤토리의 타입 별 정렬(item_type)에 사용될 enum 정보를 저장함.
            아이템들에게 item_type 추가. item_type을 처음에는 string형태로 "potion"과 같은 형태로 저장했으나, sorted()에서 key값을 건내주는 과정에서 string을 int로 변환해야하는 번거로움 때문에 enum 오브젝트로 대체함. 
            인벤토리 내에 아이템이 종류별로 다른 색상으로 표시되게 변경.
            인벤토리 내의 아이템들을 종류별로 sorting 할 수 있는 기능 추가. (같은 종류 내에서는 아직 sorting이 불가능함.)
            아이템들에게 price 추가.
            dungeon generation의 tunnel generation을 약간 변경함. 기존 방식은 생성된 순서되로 방들이 저장된 리스트에서 방 두개를 순서대로 꺼내 각 방들에 존재하는 모든 문을 서로 연결하는 방식이었는데, 이 방식은 던전을 지나치게 지저분하게 만든다고 판단되어 방식을 변경함. 현재 방식은 생성된 방들을 x축, y축 기준으로 정렬한 리스트를 각각 하나씩 만들고, 이렇게 만들어진 리스트들에서 순서대로 방을 두개씩 빼서 랜덤으로 문을 하나씩만 정해 서로 잇는 방법임.
20200810 - 던전 내 방들에 풀을 생성하는 grow_grass 함수 작성. 풀의 생성위치, 규모, 랜덤성/밀집도를 조절할 수 있음. 본 함수는 다른 지형들의 생성에도 활용할 수 있음.
            풀이 방 상단부 벽 위치에 생성되는 버그 수정.
            tile_types에 디버그 시 사용하는 DEBUG 타일 추가.
20200811 - sparse grass 추가, dense grass 밟을 경우 sparse grass로 변경되는 기능 추가
            타일 생성 시 색상 랜덤화하는 기능 추가하려 했으나 예상외로 많은 코드 수정이 필요해져서 보류.
20200812 - 타일 생성 시 색상 랜덤화하는 기능 추가. 배경색과 글자색 중 원하는 것을 선택적으로 랜덤화할 수 있음. 현재 floor, dense_grass 타일들의 색상은 랜덤화해서 생성됨.
            인벤토리에 같은 종류의 아이템이 Stack 되는 기능 추가.
            아이템 엔티티에 stack_count, stackable 인스턴스 변수 추가.
            Hud 및 메세지 로그에 아이템 관련 문자열이 표시될 때 아이템의 갯수도 함께 표시되도록 변경.
20200817 -  procedural generation 전체적으로 대대적인 개선이 이루어짐.
            1) tilemap 데이터를 기존 각 Room 인스턴스들에게 저장하던 방식에서 GameMap에 저장하는 방식으로 변경. -> 메모리 사용량 대폭 감소 (tunnelmap의 경우 처음던전 생성 이후 사용되지 않는 값이므로 굳이 gamemap 클래스에 저장하지 않음.)
            2) 방 형태에 대한 정보들을 저장하는 room_factories.py 생성. procgen.py 코드가 너무 길어지는 것을 방지하기 위함.
            3) generate_dungeon 함수를 여러 부분으로 분할. generate_earth, generate_rooms, generate_terrains, generate_tunnels, generate_entities로 분할함. 이로서 1) 차후 추가/보수가 용이해졌으며, 2)미미하지만 메모리 개선도 이루어졌고, 3)map_width와 map_height를 동적으로 값을 전달할 수 있게 되었음.
            4) 모든 room class에 terrain 컴포넌트(단 엔티티 컴포넌트가 아니기 때문에 component 폴더에 들어있지는 않다.) 추가. 이 terrain을 바탕으로 terrain_generation이 이루어짐.
               terrain 컴포넌트에 여러 변수값들 추가, 그리고 추가한 변수값들로 procedural generation이 영향을 받도록 procgen.py 코드 수정 및 추가함.
               현재 추가된(실질적으로 기능하는) terrain의 변수값으로는 spawn_item, spawn_monster, has_door, gen_grass 가 있음.
20200818 -  인 게임 시간(속도) 시스템 추가. + 인게임 턴 추가.
            모든 엔티티(아이템 포함)는 action_point와 action_speed 값을 가지게 되며, action_point 60을 소모하여 한 번의 액션을 수행할 수 있음.
            플레이어의 한 턴이 끝나면 모든 엔티티(현재로서는 액터들만)들은 플레이어의 action_point가 60이 될 때까지 action_speed만큼 여러 차례 회복함. 이 과정에서 최대한 저장할 수 있는 action_point는 180이며, 즉 이론적으로 게임 상에서 가장 빠른 액터는 플레이어의 3배의 속도를 낼 수 있다.
            (즉 몬스터의 agility값이 아무리 높아도 플레이어 agility 값의 3배 이상이면 다 속도가 동일하게 플레이어 3배로 처리된다.)
            액터의 경우 action_speed, 즉 매 턴 당 action_point 회복량은 자신의 agility값에 비례한다.
            플레이어의 턴이 끝나면, 모든 엔티티들의 action point값이 증가하며 그 후 엔티티들은 액션을 실행하게 되는데, 이때 엔티티들은 가진 action point를 최대한 사용해서 액션을 실행한다.
            
            1) 이 과정을 정리하면 아래와 같다

            <게임 시작 전>
            player action point : 60(초기값)
            player action speed : 10
            fast monster action point : 60(초기값)
            fast monster action speed : 30
            slow monster action point : 60(초기값)
            slow monster action speed : 5

            <턴1>
            플레이어 턴 실행, 액션포인트 소모 (-60)
            >> pl : 60 -> 0
            몬스터들 턴 실행, 액션포인트 소모 (-60)
            >> fm : 60 -> 0
            >> sm : 60 -> 0

            <턴 1과 2 사이>
            플레이어 액션포인트가 60(최대치)이 될 때까지 n번 action_speed만큼 회복함.
            존재하는 모든 액터들도 마찬가지로 n번 각자의 action_speed만큼 회복함.

            pl actionspeed = 10이므로 n = 6임.

            플레이어 : 10 * 6 만큼 회복
            >> pl : 60
            빠른 몬스터 : 30 * 6 만큼 회복
            >> fm : 180
            느린 몬스터 : 5 * 6 만큼 회복
            >> sm : 30

            <턴2>
            플레이어 턴 실행, 액션포인트 소모 (-60)
            >> pl : 60 -> 0
            빠른 몬스터 턴 실행, 액션포인트 소모 (-60)
            >> fm : 180 -> 120
            빠른 몬스터 2번째 턴 실행, 액션포인트 소모 (-60)
            >> fm : 120 -> 60
            빠른 몬스터 3번째 턴 실행, 액션포인트 소모 (-60)
            >> fm : 60 -> 0
            느린 몬스터 턴 실행불가
            >> sm : 30

            [ 결과 ]
            플레이어 턴1
            빠른 몬스터 턴1
            느린 몬스터 턴1
            플레이어 턴2
            빠른 몬스터 턴2
            빠른 몬스터 턴3
            빠른 몬스터 턴4


            2) 플레이어와 몬스터의 액션스피드를 각각 x, y라고 할 때, 매 턴 얼마만큼의 추가 액션포인트를 얻어가는 지 구할 수 있다.

            n = 60 / x
            매 턴 추가로 얻는 액션 포인트 = abs(n * (x - y))

            매 턴 추가로 20씩 얻는다면 20 * 3 해서 x는 3배수 턴마다 자신만 행동할 수 있는 턴이 생기는 셈이다.

            x(플레이어)는 y(몬스터)에 대해 abs(x - y)/x + 1 * 100 %의 속도를 가진다.

            eg)            
            30 10 일때
            60 20 1 0
            60 40 2 0
            60 60 3 1

            30은 10에 대해 약 167%(500/3)의 속도를 가진다.

            60은 10에 대해 약 184%(1100/6)의 속도를 가진다.
20200819 - 애니메이션 처리 방식에 대한 아이디어 두가지 고안:
            1) main 함수의 game loop 상단의 render에서 (정확히는 engine.render에서) 게임맵 등을 렌더링 하기 전 이전 gameloop에서 연산되었던 것들의 애니메이샨을 렌더링하는 방법
            2) 애니메이션을 하나의 이벤트로 취급해서 engine.event_handler.handle_events에서 처리하는 방식. (아마 플레이어의 인풋이 끝난 직후, 그리고 엔티티 ai들의 액션이 처리된 직후 애니메이션 이벤트가 처리될 것으로 추정됨.)

            1번 방식을 사용하려면 이벤트를 입력받기까지 기다리는 시간이 현재 None(무한히 기다림)으로 설정되어있는데, 이를 애니메이션 속도에 적합하게 변경해주어야 함.
            단 매 초마다 화면을 다시 렌더링행야 하므로 게임 작동에 다소 부하가 걸릴 가능성이 존재함. 또한 현재로서는 1초에 한 번 화면 갱신하는 게 최고속도인 것으로 추정되므로 애니메이션의 처리 속도가 굉장히 느리게 나타날 수 있음.
            또한 애니메이션 처리 도중 인풋이 발생하면 애니메이션이 가속되는 현상이 발생할 수 있음. 장점은 engine.render 한 군데에서만 화면의 출력이 이루어지기 때문에 관리하는게 수월해짐. 
            그러나 1번 방식은 권장되지 않음.

            2번 방식을 사용하면 애니메이션 처리를 이벤트로 취급함.
            애니메이션의 속도(한 프레임이 끝나고 다음 프레임으로 넘어가는 속도)는 이벤트 하나가 처리되는 속도와 동일함. (즉 굉장히 빠를 것으로 추정됨.)
            프레임 간의 속도를 조절하기 위한 방안으로 시간 관련 라이브러리 등을 사용하는 것을 고려해 볼 수 있음.
            한 애니메이션 재생이 끝나고 다른 애니메이션으로 넘어가는데 걸리는 시간도 굉장히 빠를 것임. 그러나 이는 특별히 속도를 조절할 필요는 없으리라 생각됨.
            2번 방식의 단점은 보여줄 애니메이션들의 리스트를 만들어서 한번의 시행에서 보여주는 것이 아닌, 애니메이션이 실행 될 때마다 개별적으로 보여주는 것이기 때문에 이를 관리하기가 번거롭다는 단점이 있음.
            장점은 플레이어가 인풋을 넣는 즉시 애니메이션이 출력된다는 점임.
            반면 1번 방식은 내가 인풋을 넣고, 몬스터들도 인풋을 넣고, 연산이 이루어지고 난 후(즉 게임루프를 한 번 돌고 나서) 애니메이션을 보여주기 때문에 한 템포 늦은 상황의 그래픽을 보여주는 것이므로 많은 버그가 발생할 수 있음.

            종합적으로 고려했을때, 애니메이션은 2번 방식으로 작업하기로 결정함.

            2번방식을 사용할 때, 동시에 여러 애니메이션을 표기하려면 (굳이 그래야 하는 상황이 존재할 지는 둘째로 치고) 애니메이션이 game_map에 어떤 식으로 표기되는지와 연관지으면 될 것으로 생각됨.
            즉 x=1, y=2에 빨간 타일을 그리는 애니메이션1, x=4, y=4에 파란 타일을 그리는 애니메이션2를 x=1,y=2에 빨강, x=4,y=4에 파랑을 그리는 애니메이션3으로 합쳐서 애니메이션3 하나만 프린트 하는 식으로 처리할 수 있을 것 같음.
            단 이렇게 되면 플레이어가 인풋을 끝마친 직후 애니메이션을 바로 처리하는 것은 불가능해짐. 즉 게임 내 모든 연산이 끝난 후에야 애니메이션 렌더링이 가능해짐.
            이는 1번 방식과 상당히 유사한 방식으로, 차이는 딱 하나 - 게임루프 상단에서 이전 프레임의 애니메이션을 보여주느냐 혹은 게임루프 최하단에서 방금 끝낸 연산의 결과를 애니메이션으로 보여주느냐 - 이다.

            애니메이션을 개별적으로 처리해야할지, 이렇게 합쳐서 처리해야할지에 대한 고민은 조금 더 해봐야 할 것 같음.
            현재로서는 개별적으로 처리하는 방식으로 개발할 계획임.
20200820 - 인 게임 애니메이션 시스템 추가. (animation.py, anim_graphics.py 추가 및 engine.refresh_screen() 추가)
            어제 고안했던 두가지 방식 중 2번 방식에 더 가까운 방식으로, 애니메이션과 맵 렌더링을 완전히 별도의 것으로 분류해놓았음.
            애니메이션 클래스는 여러 개의 프레임 정보로 구성되어있고, 하나의 프레임 정보는 여러 개의 그래픽 정보로 구성되어 있으며, 하나의 그래픽 정보는 그래픽 정보(anim_graphics.py 내의 딕셔너리 중 하나를 선택), 노출 시간(=1프레임 당 시간), 현재 프레임에서 이 그래픽이 가장 마지막인지 아닌지, 등의 정보를 담고 있다.

            주요 기능 및 변경점들을 정리하면
            1) gamemap 데이터나 engine.render()과 전혀 상관 없이, 게임 내 어느 시점에서든지 화면 상에 애니메이션을 표시할 수 있음.
            2) 애니메이션은 여러 프레임으로 구성할 수 있으며, 한 프레임 당 몇 초인지를 직접 실수 단위로 입력해서 조작할 수 있음. (time.sleep() 사용)
            3) 심지어 각 프레임 별로 몇 초 동안 표기할 지를 개별적으로 지정할 수 있으며, 따라서 점점 빨라지거나 점점 느려지는 애니메이션들도 구현할 수 있음.
            4) main()에서 엔진에 self.console과 self.context 정보를 넘겨줌으로서, 이제 코드 어느 곳에서나 콘솔과 게임창에 직접 접근할 수 있게 되었음.

            그 외: closed_door의 walkable이 True로 설정되어있던 버그 수정.
20200821 - 불(화염) 추가.
            불, 가스 등 액터와 타일 중간에 위치하는 엔티티들을 별도의 엔티티로 분류했음. 이를 semiactor라고 이름 붙였으며, semiactor를 관리하기 위해 필요한 여러 요소들 -SemiActor 클래스, Entity의 semiactors 프로퍼티 등- 을 추가함.
            모든 세미액터들은 액터들과 별개로 턴을 진행하며, 액터 턴 직후 턴을 처리한다. 세미액터 역시 action_point를 기반으로 턴을 진행하며, 세미액터의 action_speed는 해당 세미액터가 얼마나 게임 상에서 빠르게 액션을 취하는지와 비례한다. (ex. 불이 빠르게 번지게 하려면 action_speed값을 높이면 된다.)
            burnt_floor을 tile_types에 추가함.
            이제 모든 엔티티는 기존 color값만 받아서 이를 foreground color로 사용하고 background color은 None으로 고정시켰던 것에서 변경되어, 처음부터 fg와 bg값을 모두 받고, bg값의 기본값을 None으로 설정하는 것으로 변경함.
            모든 세미액터들은 lifetime을 가지고 있으며, 한 번 액션을 취할 때마다 lifetime이 1씩(값은 조정할 수 있음) 감소해, 0에 도달하면 gamemap.entities에서 세미액터를 삭제함.
            이제 모든 타일들은 flammable 변수를 bool값으로 가지게 되었음.

            현재까지 추가된 불과 관련된 주요 기능들을 정리하면
            1) flammable 한 타일 위에만 불이 붙음.
            2) 주변의 다른 flammable한 타일 중 세미액터(불)이 없는 타일에 불이 옮겨붙음.
            3) 불은 lifetime만큼 지속되며, lifetime이 0이 되면 불이 꺼짐과 동시에 타일이 burnt_floor로 변함.

            앞으로 추가해야 할 기능들을 정리하면
            1) 불 데미지 (fire resistence)
            2) 불 그래픽 우선순위 설정
            3) 불이 바닥에 놓은 일부 아이템을 파괴할 수 있게 할 것 -> Entity
            4) 불이 상황에 따라 인벤토리 내의 아이템까지 파괴할 수 있게 할 것
            5) 불 그래픽 색상값이 시간에 따라 변하도록 만들기 -> 처음에는 하양, 노랑 계열로 시작해서 lifetime이 줄어들수록 빨강 계열로 변화되게 만들것.
20200822 - 불 그래픽이 시간에 따라 랜덤하게 생성되게 변경. (단 처음 불꽃이 붙은 순간의 그래픽은 항상 동일함.)
            SemiActor의 렌더링 order enum에 추가. 불이 붙은 첫 턴에 불꽃이 엔티티 그래픽을 덮고 그 다음 턴부터 엔티티가 보이는 버그가 존재하나, 큰 지장이 없을 뿐더러 오히려 일부 상황에서는 이점으로 작용할 가능성이 있기에 현 상태를 유지하기로 결정함.
            다만 플레이어의 그래픽을 가리는 건 다소 문제가 있다고 판단되어 수정을 시도하려고 ACTOR 보다 상위 렌더링 order인 PLAYER enum을 추가했으나, 여전히 불 그래픽이 최상단에 표시됨.
            ^매 게임 루프마다 game_map.sort_entities()를 실행함으로서 해결함.
            불 데미지 기능 추가.
            현재로서는 불이 고정데미지를 가하는 방식이지만, 차후 불붙음 상태를 추가하고 fire resistence 등이 추가되면 연산을 조금 더 복잡하게 변경해야함.
            적이 시야 내에서 죽었을 때에만 로그 메세지를 출력하도록 변경함.
            현재 ai들은 불이 붙어도 움직이지 않는데, 이를 유지한다면 차후 시야 사각에서 불로 공격하는 방식이 지나치게 유리한 플레이를 만들어 낼 우려가 있음. ai 지능에 따라 불을 피하도록 만들거나, 혹은 피하지 않더라도 최소한 시야 밖에서 ai가 랜덤하게(혹은 방사이를 떠돌아다니거나) 움직이는 정도는 만드는 게 권장됨.
20200823 - 불이 타일 위의 아이템을 태우고, 인벤토리의 아이템도 태우는 기능 추가.
            item_state.py컴포넌트를 제작했고, 모든 아이템 엔티티들에게 item_state를 부여함. 앞으로 액터들에게도 actor_state를 부여할 계획임.
            state는 현재 해당 엔티티의 상태가 기재되어있음.
            모든 아이템에 flammable 값을 추가함. 이 값은 다른 ~able값들과는 달리 컴포넌트를 받는 게 아니라 실수값을 받으며, 해당 실수값은 이 엔티티가 불에 붙었을 때 발생하는 여러 효과에 대한 확률에 영향을 줌.
            input_handler의 인벤토리 창에서 만약 아이템이 특수한 state에 놓여있을 경우 해당 state를 출력하는 기능 추가. 불이 붙었으면 [on fire] 라는 문구가 가장 우측에 빨간색 글씨로 렌더링됨.
         
            이로서 0821 적어놨던 추가해야할 기능들은 전부 추가가 됨. (일부 세부적인 기능 제외)

            앞으로 불 관련해서 추가해야 할 것들은
            1) 인벤토리 stack 시스템 개선 -> 플레이어가 아이템을 마음대로 stack하고 destack할 수 있게 해야함.
            2) 1번항목을 만들었다면 해당 기능을 사용해, 인벤토리 내 아이템에 불이 붙었을 경우 stack 전체에 불이 붙는 게 아닌, 개별적으로 각각의 확률에 맞게 불이 붙게 해야함.
            3) 인벤토리 stack 시스템 개선2 -> 아이템이 인벤토리에 들어올 때 현재는 이름 정보만 확인해 이름이 같으면 같이 stack 해버리는데, 이제 state가 추가된 이상 아이템의 state까지 대조한 후 stack해야 함.
            4) 인벤토리 자체의 fireproof 기능 추가. 단 이건 나중에 equipable들이 추가된 후에야 제작이 가능할 듯 함.
	    
            sources 폴더 만들고 해당 폴더에 타일셋과 오디오를 이동시킴.
20200824 - 불이 붙어 탈 경우 항상 red로 표시되는 건 지나치게 불필요하다고 생각되어 플레이어 인벤토리 내의 아이템이 불탔을 때 / 불이 붙거나 세졌을 때만 red로 표시했음.
            또한 몬스터들의 인벤토리의 아이템에 불이 붙었을 때 해당 몬스터의 이름을 출력하도록 변경함. (이 기능은 아직 디버그 안됨 TODO)
20200825 - 엔티티 인벤토리에 is_fireproof 추가, is_fireproof == false일때 아이템 불붙이는 기능 추가.
            카메라 시스템 추가.
            카메라 시스템을 추가하면서 좌표가 절대좌표와 상대좌표로 분리되었음. 따라서 이를 다른 한 쪽으로 변환하는 함수를 Camera 클래스에 넣었으며, 마우스의 경우 이러한 변환 연산을 할 일이 잦으므로 Engine에 mouse_relative_location 프로퍼티를 추가함.
            애니메이션이 카메라 경계를 뚫고 반대편으로 삐져나오는 버그 수정.
            마우스 입력을 화면상의 카메라 좌표와 연동되게 변경.
20200826 - 던전 구조를 대대적으로 개선함.
            기존 터널 생성 방식은 모든 방들을 x, y축으로 두번 정렬한 후 터널을 각각 정렬한 리스트별로 한번씩 총 두번에 걸쳐 생성하는 방식이었음. 그러나 이 방식은 맵을 지나치게 열린 구조로 만들어 게임의 난이도를 낮추고, 또한 모든 바로 옆에 붙은 두 방이 존재할 수 없다는 점에서 게임의 흥미도를 낮춤.
            때문에 이 방식을 수정하기 위해 다음과 같은 변화를 주었음.
            1) room의 in_bounds를 판정하는 조건변경. >> 기존에는 door convex와 outer wall이 닿기만 하면 충돌되었다고 판정했는데, 이렇게 하다보니 방과 방 사이에는 반드시 2칸의 공백이 생기게 되었음. 이를 변경해 이젠 방의 inner area에 닿는지만을 확인하고, outer wall 끼리는 서로 닿더라도 충돌한 것으로 간주하지 않음.
            2) x축 거리, y축 거리로 방을 정렬하는 대신, 방의 실제 거리(좌상단 좌표간의 거리)를 기준으로 정렬하는 시스템 추가.
            3) 문이 생성되는 시점을 generate_terrains에서 generate_rooms로 변경. 구체적으로는 door_convex가 생성되는 시점에 문도 동시에 같이 생성됨. 이 변화로 인해 문이 생기지 말아야 할 위치에 생기는 버그가 수정됨.

            아직 수정해야할 점 : 아무 곳과도 연결되지 않는 문이 다소 존재하는데, 이 문을 없애거나, 연결하거나, 다른 식으로(pathos처럼) 활용할 방법을 찾아야 함.
20200827 - 몬스터 기획안 작성.
20200828 - 세이브/로드 기능 제작. 타이틀 스크린 제작.
            몬스터 기획안 작성.
            configuration을 게임 외부로 뺄 수 있게 만들어놓음.
            save, load 기능 제작 시도했으나 알 수 없는 이유로 pickle이 동작하지 않아 실패. 아마 tcod가 c의 기능을 일부 사용하는 것 때문이라고 추측되는데, 확실치 않음.
            >> 극적으로 버그 수정. 원인은 Engine 내에 context와 console 정보가 저장되어있기 때문이었음.
            세이브된 파일 불러올 때 일부 로그 메세지가 두번씩 뜨는 오류 해결.
20200829 - 타이틀 로고 제작. (임시)
            몬스터 기획안 작성.
            generate_terrain의 grow_grass함수 성능 대폭 향상. (numpy.where()함수와 zip() 사용)
            entity_factories.py를 actor, semiactor, item factories로 3분할함.
            tunnelmap 데이터를 gamemap 안으로 옮김. 맵 생성이 끝나도 터널맵 정보가 저장됨.
            아이템 및 몬스터 생성 방식을 random.choices의 weight argument에 각 엔티티들의 rarity가 담긴 리스트값을 건내주는 방식으로 변경, 속도 개선 + 관리의 수월함을 기대할 수 있음.
            gamemap의 inner_tiles (내부 타일들 슬라이스들을 좌표들 리스트값으로 반환함) 프로퍼티를 사용해 generate_terrain의 성능 대폭 향상.
            room.terrain의 grow_grass 내에 max_scale, fixed_scale 수치 추가. max_scale로 대략적인 해당 지형의 규모를 인풋할 수 있고, 정확히 규모를 정해놓고 싶으면 fixed_scale을 True로 만든 후 max_scale값에 원하는 값을 넣으면 됨.
            door 갯수를 기존에는 random.randint로 정했는데, 보다 더 플레이어 친화적인 던전을 만들기 위해 random.choices([1,2,3,4], [확률], k=1)을 사용함. 현재는 문이 2개일 확률을 가장 높게 설정해놓았음.
20200830 - 계단, ascend와 descend 시스템 추가.
            계단은 terrain generation과는 별개로, 어떤 방의 terrain과 관게없이 랜덤으로 배치됨.
            계단의 렌더링 오더는 굳이 신경쓰지 않기로 함. (dark일 때에도 밝게 보이기 때문.)
            아직 몬스터의 descend는 제작하지 않음.
            gamemap의 world 데이터가 세이브/로드 시 증발하는 오류 수정.
            새로운 gamemap 생성하는 방식을 기존 from procgen import generate_dungeon 한 후 generate_dungeon()하던 방식에서, engine에 generate_new_dungeon함수를 제작해 해당 함수를 호출하는 방식으로 변경.(circular import 에러 때문.)
20200831 - 기존에는 entity.parent가 gamemap과 inventory의 주인 두가지 의미를 모두 가질 수 있었는데, 이러한 방식은 지나치게 혼란을 야기한다고 생각되어 이를 수정함. 앞으로 parent는 해당 엔티티를 컴포넌트 혹은 변수로 가지는 상위 엔티티를 가리키며, 게임맵은 별도로 gamemap변수를 만들어 해당 변수에 저장함.
            >> 위 수정에 의해 발생한 층간 아이템 이동 시의 버그들 수정.

            Equipable, Equipments 컴포넌트 제작.
            Equipable은 아이템에게 부착되는 컴포넌트로, 해당 아이템을 장착했을 경우 얻는 스테이터스 상의 변화들과, 해당 아이템을 강화했을 때 어떤 스텟이 얼만큼 변화하는 지에 대한 정보를 담고 있음.
            Equipments는 엔티티에게 부착되는 컴포넌트로, 해당 엔티티가 어떤 아이템들을 장착하고 있는지, 또 아이템 장착과 탈착의 처리, 그리고 아이템 착용 시 엔티티의 스텟을 변화시키는 처리가 이루어진다.
            >> 주의해야 할 점은, equipments에서 변화시키는 스텟은 장착엔티티의 bonus_xxx 스테이터스들로, 엔티티의 strength, protection과 같은 스텟 자체를 직접 건드리지는 않는다.
            >> 또한 전투 처리 시에는 엔티티 내부에서 기존 스텟에 bonus_xxx 스테이터스들을 더한 값을 사용함으로서, 엔티티 고유의 스테이터스와 장착으로 얻은 스테이터스를 분리해서 사용한다.
            그외 인벤토리 상에서 장착된 아이템들은 태그로 표시하는 것 추가.
            Status 내에 resistances 값들 추가함, 필요없는 프로퍼티들 삭제함.
            같은 부위에 동시에 두 개의 아이템을 equip할 수 있던 버그 수정.
            이미 장착한 아이템을 다시 장착할 수 있던 버그 수정.
            EquipItem, UnequipItem 액션 추가.
20200902 - 방과 터널 생성을 마친 후 통로 연결에 사용되지 않은 door_convex들을 모아 재사용하기 위해 해당 좌표들을 찾는 함수인 adjust_tunnel함수 작성. (비어있는 convex들의 좌표를 찾는 것까지만 작성됨.)
            
            actor_state 컴포넌트 제작. 다양한 변수들 작성함.

            actor_state 내부의 is_burning 변수를 실제로 게임 내에서 작동하게 fireRule을 수정하고 engine에 handle_actor_state 함수를 추가함.
            불 데미지는 이제 rule.py에서 직접 엔티티에게 가하는게 아니라, 다음과 같은 단계를 거쳐 동작함.
            >> 1) handle_semiactor_actions()에서 fire의 FireRule이 동작해 불 위치에 있는 엔티티의 actor_state.is_burning 값(리스트)을 변경한다.
            >> 2) handle_actor_state()에서 if is_burning != [0,0,0,0](불이 붙었는지 확인)를 거쳐, True일 경우 해당 엔티티의 actor_state 내부에서 데미지를 처리한다.

            또한 불 데미지는 이제 액터의 fire_resistance 값에 영향을 받는데, fire_ressitance가 1이 아니라면 불은 일단 붙으며, fire_resistance 만큼의 확률로 한 턴이 지날 때마다 불이 꺼질 기회가 부여됨.
            불 데미지는 기본데미지와 추가데미지로 구성되어 있으며, 매턴마다 기본데미지에 추가데미지가 누적되어 딜이 점점 강해짐.
            불을 처음 붙일 때 불이 최대 몇 턴까지 갈 수 있는지가 주어짐. (즉 fire_resistance = 0이라도 영원히 불이 붙지는 않음.)
            
            갑옷 장착 시 착용 부위가 표시되게 변경
            >> 해당 과정에서 발생한 갑옷의 equipable.is_equipped 관련 버그 수정. (is_equipped는 이제 boolean 형태가 아니라 해당 장착부위의 이름을 나타내는 str형태로 변경.)

            아이템이 불이 붙은 후 드랍하면 is_burning은 True로 유지되나, burntness 가 3이 되도 탔다는 로그만 뜨고 실제로 타지 않는 버그 발생.
            >> 수정 완료. 원인은 item_state.burn()내부의 parent.parent가 문제였음. parent.gamemap으로 변경함.

            엔티티가 죽을 경우 시체로 변하는 대신, 시체 아이템을 드랍하고 자신은 삭제하는 시스템 추가.
            >> 아직 시체를 먹는 기능, 시체를 굽는 기능과 영양분 기능, 또 시체 부활 기능을 위해 엔티티 정보를 시체에 저장하는 기능 등은 제작하지 않음.
20200903 - 아이템에 불 붙었을 때 일부 로그메세지 색상이 잘못 표시되는 버그 수정.

            먹을 수 있는 아이템과 허기 시스템 작성.
            1) Edible 컴포넌트 제작
            2) actor_state에 actor_gets_hungry()함수 추가해서 매 턴마다 허기가 닳는 시스템 구축
            3) spoilage 변수를 edible에 추가해 음식이 상하는 기능 구현, 또한 음식이 상하는 속도를 조절할 수 있도록 작성.
            4) 액터 엔티티에도 edible을 저장함으로서, 시체를 떨굴 때 서로 다른 종류의 시체를 떨구는 시스템 구현.

            아직 먹는 인풋을 받는 게 구현되지 않았지만, 먹을 경우 이뤄지는 연산을 위한 함수들은 구현완료.
20200904 - 아이템 먹는 기능 추가.
            시간이 흐르면 아이템이 썩는 기능 추가.
            >> 해당 기능을 쉽게 구현하기 위해 item 엔티티에 remove_self()함수 작성. 이 함수는 아이템이 누군가의 인벤토리에 있던지, 혹은 게임맵 상에 존재하던지 확인해서 삭제해준다.
20200906 - room factories에 ㄱ자 방 추가. (90도씩 회전시켜 총 4가지 형태 중 하나가 랜덤으로 결정됨.)
            gui 형태를 잡아놓음.
	         TODO : 가끔 한번씩 맵이 단절되는 에러가 발생함. > 에서 <까지 pathfinder로 path를 구해서 만약 path가 없을 경우 1) 맵을 다시 생성하거나 2) 맵에 통로를 뚫어버리거나 하는 방법이 있음.
20200907 - 계단 두개가 서로 연결되지 않는 버그를 임시방편으로 수정함.
            >> generate stairs에서 두 계단의 위치를 랜덤으로 정한 후 실제로 배치하기 직전에 두 계단 사이를 연결하는 통로가 존재하는지 tunnelmap을 활용해 확인함. 만약 두 계단이 막혀있다면 계단 위치를 다시 랜덤으로 설정함.
            >>> 그러나 문제가 있는데, 두 계단 사이가 실제로는 안막혀있음에도 막혀있다고 판정되는 경우가 있었음. 그렇다고 게임에 지장을 주는 수준은 아니기에 일단은 수정 보류함.
            
            맵 통로 버그의 원인 중 하나는 충분하지 못한 room 밀도라고 판단되어 초기 room 숫자를 1000개에서 3000개로 증가시킴. 던전 생생 소요시간은 거의 동일하므로 성능에는 큰 지장 없음.
            
            Tunnel generation 에서 타일을 까는 과정에서 현 타일이 door이 아닐 경우 tile을 floor로 변경하는 기존 시스템은 문제가 발생할 소지가 있었음. 타일이 grass같은 terrain type일 경우에도 floor로 바꿔버린다는 문제임.
            >> 때문에 이제는 타일이 void인지만 확인하고, void일 경우에만 floor로 변경하고 그 외의 모든 경우는 타일을 변경하지 않음.
            
            empty convex들을 통로로 연결하는 시스템 추가
            >> (연결하기 전 굳이 거리순으로 정렬하지는 않는다. numpy에서 convex를 tilemap 2darray에서 search할 때 이미 어느정도 정렬된 상태로 반환하기 때문. 또한 기존 tunnel generation은 하나의 room이 리스트에서 자신 앞의 room과 자신 뒤의 room 이렇게 두번 연결이 되었는데, convex의 경우엔 굳이 그렇게 하지 않고 두개씩 pop해서 서로 잇고 그걸로 끝낸다.)
            >>> empty convex들을 서로 한차례 잇고 나서도 아무와도 이어지지 않은 convex들이 존재하는데, 이 convex들은 초기에 계획한 대로 특수한 지형을 생성하는데 사용할 예정이다.
            
            인벤토리에서 이제 item_state 중 데미지와 관련된 state들을 표시해준다. (ex. burntness)
            
            인벤토리에 아이템을 stack 하기 전 아이템의 세부적인 item_state가 동일한지 확인하고 동일해야만 stack한다. 즉 이제 burnt 아이템들은 같은 종류, 같은 이름이어도 non burnt아이템들과는 stack되지 않는다.
            >> 두 아이템이 서로 동일한지 확인하는 변수 check_if_identical()을 item_state.py에 작성함. 주의해야 할 점은 이 함수는 두 아이템의 name값과 item_state 컴포넌트 내에 있는 값들만 비교하므로, 그 외의 컴포넌트에 있는 값들은 비교하지 못한다.
            >>> 즉 부패 시간이 서로 다른 두 고깃덩어리를 주었을 때 이 함수로는 두 아이템의 차이를 구분해낼 수 없다.
            >>>> 이 문제를 해결하기 위해, 각종 장착품들과 각종 음식물들은 처음 생성될 때 부터 stackable = False로 설정해두어 이러한 사태가 발생하는 것을 미연에 방지했다.

            갑옷을 입은 상태에서 갑옷이 탈 경우 갑옷의 보너스가 유지되는 버그 수정.
            >> 해당 버그를 수정하면서 아이템 엔티티들의 removal을 하나의 함수로 통합함. 이전 방식대로였다는 불이면 불, acid면 acid, 따로따로 item이 인벤토리에 있는지, gamemap에 있는지 일일히 확인해주어야 헸겠지만, 이제는 Item클래스 자체에 remove_self라는 함수를 작성해 하나로 통합함.
            >>> equipments.py 컴포넌트 내의 equip_equipment()와 remove_equipment()에 새로운 argument "forced"를 추가함. 만약 forced = True라면 관련된 모든 로그 메세지를 표시하지 않으며, 오류가 발생해도 raise error 대신 return None을 함.
20200908 - 앞으로의 계획 :
            < 주요 사항들 >
            0) AI의 적 타겟팅 시스템 추가. (지들끼리 서로 타겟팅 가능하도록.) <O>
            1) AI들이 시야 바깥일 때 취하는 행동 추가, 평화적인 AI 추가, Confusion을 ai가 아닌 state에서 처리될 수 있도록 수정. <O>
            2) 마법 시스템 추가, 관련된 GUI 추가. <O>
            3) 원거리 공격, 마법 공격 가능한 액터, AI 추가. <O>
            4) 아이템 도감 추가, 몬스터 도감 추가 (아스키 아트)
            5) 세이브 슬롯 여러개로 확장.
            6) biome 추가. (terrain 보다 넓은 개념) <O>
            7) blessed, cursed 추가, 및 아이템들 그래픽 랜덤화 기능 추가 <O>
            8) 경험치 시스템 추가. <O>
            9) 몬스터 스포너 시스템 추가. <O>
            10) 상점 추가 (전투 이외의 상호작용이 가능한 액터 추가)
            11) 승리 조건 추가 <O>
            
            < 세부 사항들 >
            0) 가스 (gas) 추가
            1) 물 관련 지형 추가 및 물 속에서의 렌더링 그래픽 변화 기능 추가
            2) 인벤토리 외의, 장착품을 관리하는 창 추가
            3) 나무, 꽃, 열매, 버섯 등 추가. (tile이 아니라 entity형태로 추가)
            4) 게임 인트로 추가(애니메이션?), 메인화면 개선 <O>
            5) Gui 개선 <O>
            6) 효과음 추가
            7) 펫에게 명령 기능 추가

            주요 사항들의 제작이 전부 끝나면 그때부터 아이템과 몬스터들의 제작과 각종 상태이상들의 제작에 돌입.
20200909 - AI 대폭 개선
            >> AI에게 타겟팅 시스템을 추가함. 타겟을 설정하는 방법은 AI의 성향에 따라 다 다르지만, 기본적으로 AI는 현재 타겟으로 설정된 유닛을 향해 접근해 공격하고, 해당 타겟이 1) 죽었거나 2) 게임에서 제거되었거나 3) 시야에서 벗어났을 경우 타겟을 None으로 리셋함.
            >>> 타겟이 리셋되었다고 바로 Idle 상태로 돌입하는 건 아니고, 타겟이 리셋되어도 남아있던 path 를 따라 계속 이동함. (이 기능을 통해 플레이어가 잠시 시야밖으로 벗어났다 해도 계속 추격할 수 있음.)
            
            기존 AI는 무조건 플레이어에게만 적대적인 한 종류밖에 없었는데, hostile to all, hostile to player, allied with someoone 이렇게 세 종류의 AI를 추가함.
            이중 hostile to all의 경우는 자체적인 시야를 사용해 적을 타겟팅함.

            allied ai의 경우 현재로썬 hostile to all을 기반으로 작성되었기 때문에 자신의 동맹을 제외한 모든 유닛을 공격하는데, 이에 대한 수정이 필요함.

            모든 AI는 이제 attacked_from이라는 변수값을 가지는데, 이 값은 status 컴포넌트의 take_damage(amount, attacked_from)함수와 관련지어 사용된다.
            어떤 유닛이 데미지를 입으면 take_damage() 함수가 작동하는데, 이떄 만약 그 데미지가 특정 유닛에 의한 것이라면 take_damage함수에 attacked_from argument에 공격자 유닛 정보를 넘겨준다.
            그러면 take_damage함수는 넘겨받은 정보를 토대로 피공격자의 attacked_from에 공격자의 정보를 집어넣고, 피공격자의 턴이 오면 피공격자는 attacked_from이 None이 아닐 경우 기존 target 정보에 attacked_from 값을 덮어씌운다.
            >> 즉, 이미 누군가와 싸우고 있더라도 다른 누군가에게 공격을 받으면 distracted 되어 공격 타겟을 변경한다.
            >>> 다행히도, 타겟을 바꾸고 공격하는 과정은 한턴안에 이뤄지기 때문에, 어떤 유닛이 다수의 적에게 한대도 때리지 못한채 타겟만 변경하다가 죽을 일은 없다.

            앞으로 추가해야할 기능 중 confusion과 관련된 아이디어 하나를 적어보면,
            perform()함수 자체에서 ai의 동작을 결정짓는 것이 아닌,
            perform_confused(), perform_normal()등 상태별로 함수를 여러개 만들어서
            perform()에서는 어떤 상태인지를 판정하고 (state) 상태를 변경한후 (state 남은 턴 삭감) 적절한 함수를 실행하는 형식으로 하면 될 듯 하다.

            결론으로 당장 해야할 것들은
            1) allied ai를 hostiletoall, hostiletoplayer 두종류로 분류하기
            2) confusion 추가
            3) 평화적인 유닛 및 neutral한 유닛 추가

            1 - 3 - 2 순서로 작업하면 될 듯 하다.
20200910 - 어제 계획해놓은 작업 세가지 모두 해결함.

           1번의 경우, 잘 생각을 해보니 alliedai는 굳이 저렇게 두 종류로 분류할 필요가 없음. 어차피 hostiletoplayer ai는 플레이어를 제외한 모든 개체와 allied 상태인것과 마찬가지이기 때문.
           3번 평화, neutral ai 추가완료.
           2번 confusion 추가 완료.
           >> ai를 confusion ai로 통째로 바꾸는 기존의 방법 대신, ai의 perform()에서 현재 상태이상이 있는지를 판단해, 상태이상이 있다면 perform_confused를 작동시키고 그렇지 않을 경우는 perform_default를 작동시키는 형태로 수정함.

            기존 hostile ai는 플레이어 시야 내에 있어야만 전투를 했는데, 이러다 보니까 펫이 플레이어 시야 밖에 있을 경우 공격 자체를 안하는 문제가 발생함.
            >> 때문에 이젠 플레이어 시야 내에 있어야 타겟팅을 하고, 타겟이 존재하기만 하면 플레이어 시야와 관계없이 전투가 이루어짐.
            >>> TODO : 펫의 경우 allied with player ai를 별도로 만들고, 플레이어 시야 외부에서도 타겟팅까지도 이루어지도록 만들어야함.

            해야 할 것들
            1) idle action 명칭을 wandering action으로 바꾸고 추가할 것.
            2) pet ai를 별도로 만들 것.
            3) ai가 플레이어가 아무리 도망쳐도 무조건 추격하는 버그존재. 이를 수정할 것. (아마 모든 ai들에게 시야를 부여해야 할 것으로 추정됨.)
20200911 - ai 개선.
            >> 기존 ai는 idle 상태일 때 waitaction만 취했는데, 이 시스템을 변경함. 이제 idle action은 해당 ai의 active 여부에 따라 wander이 될 수도 있고 wait가 될 수도 있음.
            >>> Wander() 기능을 추가해 ai가 맵상의 임의의 좌표를 목적지로 정하고, 해당 목적지가 walkable일 경우 해당 목적지로 이동하는 형태로 변경함.
            >>>> 또한 wander하던 도중 길이 막히면 새로운 좌표를 임의로 정해 다시 wander하도록 만듬.
            >>>>> 원래는 모든 유닛들이 항상 wander하도록 만들려고 했으나, 1) 적대적인 유닛들을 지속적으로 마주쳐 게임이 너무 어려워지는 문제 2) 게임 자체의 속도저하 때문에 시스템을 변경함.
            
            변경된 시스템은 다음과 같음 :
            모든 유닛은 active라는 변수를 False 값으로 가진 채 스폰됨.
            만약 유닛이 플레이어의 시야에 한번이라도 들어있는 채 자신의 perform()함수를 실행했을 경우(즉 magic mapping 같은 건 해당되지 않는다) 이 active가 True로 변경됨.
            모든 유닛은 현재 타겟과 경로가 없을 경우 idle action을 취하는데, 이 idle액션은 active==True일 경우는 wander()이고, active==False일 때는 WaitAction임.
            결과적으로 플레이어가 최대한 체감할 수 없도록 유닛들의 움직임을 제한함.

            pet ai를 추가함.
            > pet ai의 경우 idle action은 플레이어에게 돌아오는 것이 idle액션을 대체함.
            >> 다만 현재로선 플레이어가 시야에 있던 얼마나 멀던 무조건적으로 길을 찾아 돌아오는데, 이 기능을 유지시켜야 할지는 앞으로 고민해봐야 할 듯함.

            neutral한 유닛이 움직이지 않는 버그 수정.
            > 원인은 타겟이 죽거나 없을 때 self.target = None으로 초기화하는 과정에서 self.path도 None으로 초기화해버리는 것이었음. 이렇게 되니까 wander()에서 생성된 path값이 날라가버려 움직이지 않는 것이었음.
            >> 때문에 이제는 타겟이 없을 때와 타겟이 죽었을 때를 분류해, 타겟이 없을 때는 self.target만 초기화하고, 타겟이 죽었을 때는 self.path까지 초기화하는 방법을 사용함.
20200912 - 인벤토리 개선.

            이제 인벤토리는 쉬프트 modifier 입력을 처리할 수 있으며, 아이템 최대 수용량이 52개로 늘어남.
            > 아이템 remove, drop 과 관련된 버그 다수 수정.

            인벤토리는 이제 리스트와 딕셔너리를 혼용해 사용하며, 딕셔너리에 핫키를 저장함. 이제 핫키 중간에 있는 아이템이 인벤토리에서 사라져도 핫키가 당겨져서 바뀌는 일은 더이상 발생하지 않음.

            9.12. v1 기준 6707줄 (주석포함)

            > modifier 판정 관련 오류 수정. & 연산자를 활용해야 했음.
20200913 - ability 시스템 추가.
            엔티티와는 별도의 객체 타입인 Ability 클래스를 작성함. 엔티티와 대체적으로 거의 유사하지만 보다 적은 정보들을 저장하고 있음.
            ability 관련 UI와 input handler 추가.

            ability 자체에는 아무 기능도 없으며, ability는 activatable을 최대 두개까지 달 수 있음. 하나는 패시브로 매 턴 실행되는 기능이고, 하나는 on_activation으로 플레이어가 능력을 사용할 떄 발동하는 기능이다.

            TODO : 작성 된 코드가 상당히 불안정하며 검토가 완전히 제대로 이뤄지지 않았음. 이를 차근차근 보수하는 작업이 필요함.

            TODO : 패시브 기능 자체가 아직 하나도 구현이 안된 상태임.

            TODO : 다양한 상황에서 테스트 해볼것.
20200914 - 패시브 어빌리티 기능 삭제.
            > 이유는 1) 장착품을 통해 패시브와 유사한 효과를 기대할 수 있음.
            > 2) 매 턴 추가로 소모되는 연산 시간이 너무 큼.

            인벤토리에 Split 기능 추가.
            > 해당 기능을 추가하는 과정에서 remove_items()함수를 일부 수정함. == 연산자 대신 is 연산자를 사용함으로서, 현재 버리려는 아이템과 인벤토리에 있는 ㅇ아이템이 메모리 주소까지 완전히 동일해야 삭제되도록 작성함.
            >> 이로서 아이템을 split해서 들고 다니는게 불이 붙어 탈 위험을 최소화할 수단이 되었음. 이는 게임플레이적으로도 나쁘지 않은 요소라고 생각함.

            인벤토리에 Throw 기능 추가.
            > 아주 많은 버그들을 수정함. 하나하나 나열하기는 어렵겠지만, 중요한 버그로 인벤토리의 split_item과 관련된 버그가 있음.
            >> split item을 할 때 엔티티를 deepcopy하는데, 이 과정에서 console과 context오브젝트는 deepcopy가 안되기 때문에 잠시 temp값에 저장해야 되는 건 기존에도 알고 있었음.
            >>> 그런데 이렇게 하면 문제점이 새로 deepcopy한 객체의 gamemap 속의 engine값의 메모리가 다르게 설정된다는 점임.
            >>>> 즉 deepcopy하는 시점에서 engine까지 완전이 싹 다 deepcopy가 되어버리기 때문에 별도의 엔진이 생성된 것임.

            굉장히 많은 버그들을 수정함. 그러나 어디서 추가적인 버그가 터질 지 모르는 상태임.
            > 대부분의 이 버그들은 engine을 deepcopy하는 과정 혹은 즉 item의 split, throw에 의해 발생하는 버그임. 이를 해결할 수 있는 근본적인 해결책은 단 하나뿐인데, 그건 바로 engine에 내장된 self.engine.console과 context를 제거하는 방법임.
            >> 현재 engine의 deepcopy와 관련되서 번거로운 연산을 추가적으로 거쳐야 되는 지점은 세군대 존재함. 1) save 할때 engine의 console, context값을 지워놔야 함. 2) inventory의 split_item() 3) inventory의 get_item_from_stack()

            잔버그 존재
            > input_handler의 raydir어쩌고에서 노란색 경로가 실제 사거리보다 한칸 적게 표시되는 경우가 있음. (troll corpse 던질때)
            > throw 애니메이션 마지막 프레임 이후 엔티티가 화면에서 잠시 깜빡거리는 현상 존재.
20200915 - 버그 수정.
            > 1) 노란색 경로 사거리 관련 버그 수정
            > 2) 애니메이션 깜빡거림을 방지하기 위해 animation 클래스에 refresh_last_frame변수를 추가함. 이 변수는 기본값 True이며, 만약 False로 설정할 경우 마지막 프레임을 렌더링하고 화면을 refresh하지 않음.
            > 3) 애니메이션 throw의 성능 문제 개선. (애니메이션을 렌더링하고 아이템이 실제로 드랍되기까지 시간이 다소 걸렸는데, 이 시간을 단축함.)
20200916 - 타이틀 스크린에 애니메이션 출력 기능 추가.
            > 타이틀 스크린과 관련된 모든 기능을 main에서 title.py로 이전함. 여기에는 세이브와 로드가 포함됨.

            Ai에 원거리 공격을 할 수 있나 확인하는 함수를 추가함.

            원거리 공격용 AI 계획은 이러함.
            > 우선 엔티티별로 ai를 다르게 설정해야 하기 때문에 ai_factories가 필요함.
            > 현재는 사거리 1 내에 들어오면 MeleeAction을 리턴하는걸로 되어있는데, 
              MeleeAction 대신 ai 자체에 get_melee_action()과 같은 함수를 raise NontImplmentedError 로 만들어놓고, ai factories에서 각 ai별로 이 함수 내에 들어갈 내용을 서로 다르게 해놓으면 뼈대는 유지하면서 유닛 간의 차별화가 가능해짐.
              원거리 공격도 이거랑 비슷한 방법으로 get_ranged_action() 함수를 유닛별로 만들고, 각 ai에서 해당 유닛이 기본적으로 가진 마법들 중 하나를 원거리 용으로 설정해놓으면 됨.
            > 마법 이외의 ranged attack은, 물건을 던지는 공격과 무언가를 쏘는 공격으로 분리해서, 던지는 ai의 경우 현재 지정된 투척물이 인벤토리에 있는지 확인하고(ex. 돌맹이) 있다면 던지고 없다면 Melee만 하도록 만들면됨.
            > 무언가를 쏘는 경우에는, 투척물 대신 탄창으로 쓰는 물건이 인벤토리에 있는지 확인하고, 있다면 fire하게 만들면 됨. (아직 쏘는 것에 대한 액션이 만들어지지 않았기 때문에 이부분은 보류)
            > 또한 ai들마다 melee range와 ranged range를 다르게 설정해줘야 함. 이 값은 ai 오브젝트 내의 변수로 새로 만들어줘야 할 듯함. self.melee_range, self.ranged_range 이렇게.
20200917 - 굉장히 오래 작업하는 바람에 기록에 누락된 부분들이 있을 수 있음.

            1) ai에 원거리 공격 기능 추가 (투사체)
            2) 유닛별 ai 분류가 가능하도록 ai_factories추가
            3) inventory의 throw의 성능 문제 때문에 ai들은 throw대신 simple_throw함수를 사용함.
            4) engine.console, context 값을 없앨 수 있는 방법을 찾았고 실제로 적용도 해보았으나, 메인 작업물에는 적용하지 않음. 이유는 engine.refresh_screen()을 아무때나 호출할 수 없기 때문인데, 이로 인해 몇몇 문제가 발생함.
            > 문제1) magic missile 레이저가 다 쏴지기도 전에 불이 미리 붙는게 렌더링되는 문제. 문제2) 인풋핸들러의 노란색 방향 gui가 애니메이션이 끝나기 전까지 지워지지 않고 겹치는 문제. 문제3) console, context값을 엔진 외부로 뺀다고 하더라도 deepcopy시 눈에띄는 성능의 향상은 이뤄지지 않음.
            5) 타이틀에 프레임이 나눠져 있는 애니메이션 추가

            이제 ai에게 스펠캐스팅 기능 주고 레벨 시스템까지 만들면 게임을 제대로 정리할 필요가 있음.

            타이틀 변경하고 주석들 및 TODO들 해결한 다음 수정할 주석들 수정하고 들여쓰기 띄어쓰기 정리부터 할것.
            그 후 트롤, 오크 지우고 각종 아이템들 싹다 날린 다음 제대로 엔티티 추가 작업을 시작해도 될듯 함.
20200920 - throw함수 및 split 등 아이템 복제와 관련된 함수들 전체적으로 리워크함.
            Item 엔티티에 duplicate_self()함수를 새로 제작함으로서, 이제 아이템들은 빠른 속도로 스스로를 복제할 수 있게 되었음.
            어떤 개체를 복제할 때 무식하게 개체 전체에 deepcopy를 가동하는 게 아니라, 개체의 id를 아이템 팩토리에서 찾아 빈 캔버스 상태의 해당 아이템 인스턴스를 새로 생성하고, 아이템 내의 item_state 내의 get_state와 set_state함수를 이용해 아이템 내부 정보를 딕셔너리 형태로 전달하고 받아 기존 아이템과 동일한 설정의 아이템을 제작함.

            이로서 아이템 투척, spliting에 관련된 다양한 문제들이 해결되었음.

            액터가 사망할 경우 아이템을 드랍하는 시스템 추가.

            액터의 초기 생성시 (spawn()함수 작동시) 액터의 인벤토리, 어빌리티 인벤토리, equipments에 초기 요소를 추가하는 함수 "initialize_actor()"함수를 제작함.
            이 함수는 플레이어에게는 현재로선 적용이 불가능함. 또 현재로선 하나의 아이템만 추가가 가능한데, 여러개 추가하는 기능 추가할것. (어렵지는 않을것으로 추정됨.)
            
20200924 - initialize_actor()에 아이템 여러 개를 추가하는 기능 추가.
20200926 - cellular_automata.py 제작.

            몬스터 스포너(리스폰) 시스템 제작.
            > game_map 오브젝트들은 이제 starting_monster_num, respawn_ratio, respawn_time, respawn_turn_left값을 가지게 됨.
            >> 각각의 값들은 순서대로 다음과 같음.
            >> 처음 게임맵을 생성했을 때 존재했던 몬스터 수, starting_monster_num에 대해 몇퍼센트 만큼의 숫자의 몬스터가 respawn을 통해 생성될 수 있는 몬스터의 최대치인가, 리스폰을 한 번 하는데 필요한 턴수(플레이어 턴수로 속도와는 관계없음), 마지막 몬스터 리스폰으로부터 흐른 시간

            몬스터 스포너는 game_map의 respawn_monsters()함수가 담당하며, 나중에 biome이 추가된다면 약간의 변경이 필요할 수 있음.
            respawn_monsters()를 실제로 가동하는 건 engine.handle_gamemap_state()이며, 이 함수는 다른 액터들의 턴과 마찬가지로 한 턴에 한 번 실행된다.

            biome에 대한 대략적인 계획 : biome 정보는 gamemap 오브젝트 내에 저장하는 게 좋을 듯 함.
            또한 biome 별로 procgen.py를 다시 쓰기보다는 procgen.py내에 있는 generate_dungeon만 다른 이름으로 새로 작성하면 될 듯 함.
20200928 - biome 관련 아이디어:
            engine.generate_new_dungeon() 내부에서 biome을 결정하는 함수를 작동하고, 그 결과에 맞게 generate_dungeon()혹은 procgen내의 다른 함수를 가동하면 될 듯 함.

            타일의 경우 아예 그냥 모든 타일들을 클래스 호출이 아닌 함수 형태로 만들어버리는 게  듯 함.
            해당 함수에서 biome에 맞는 색, 모양의 타일을 리턴하는 형식임.
            또 기존 색상 randomize과정을 거치는 타일들은 해당 과정도 같이 거치면 됨.

            이제 게임의 세부적인 기획을 해야 할 시점에 옴. 가장 급한 사안인 레벨링 시스템, 그리고 세부적인 terrain과 biome부터 기획하면 좋을 듯 함.
20200929 - terrain 생성 관련해서 큰 변화를 줌.
          이제 모든 방들은 terrain을 먼저 정하고, 해당 terrain 데이터 내부에 들어있는 정보를 통해 가로,세로 길이와 방의 형태를 결정함.
          즉 이제 특정 terrain들에 한해 항상 큰 형태로 생성하는 것이 가능해짐.
          > 때문에 이제 initializer에서 room_max_width랑 height값을 더이상 파싱하지 않음.

          굉장히 많은 내용들을 변경하고 추가함.

          1. biome 추가.
          biome이란 terrain보다 넓은 개념의 지형조건으로, 하나의 게임맵은 반드시 하나의 biome을 가지고 시작한다.
          biome에서 정할 수 있는 것들은
          맵 크기, 몬스터 regen과 관련된 수치들, 어떤 terrain들이 생성될 수 있는지 결정, 해당 게임맵의 tileset(타일 종류별 그래픽과 특성), 어떤 몬스터가 생성될 수 있는지 등이 있다.
          현재 terrain과 몬스터 관련된 기능은 아직 추가되지 않은 상태다.

          2. tile_types.py 대거 변경.
          기존에는 특정 타일을 맵에 생성할 때 tile_types.py에서 직접 클래스 인스턴스를 호출해다가 제작했고, 또 간혹 색상 랜덤화가 필요한 경우에만 함수형태로 호출했는데,
          이제부터는 모든 타일을 함수 형태로 제작한다.

          또한 타일 내부에 tile_name, tile_id 정보를 추가함으로서, 기존에는 어떤 타일이 어떤 위치에 있는지 확인하려면 tile_types의 클래스와 비교해야 했던 것을, 이제는 해당 위치 타일의 id값만 보고서도 확인할 수 있게 만들었다.

          3. 게임맵에 tileset 추가
          tileset이란 주로 biome에 의해 결정되는 일련의 타일 데이터베이스 값으로, 타일명 : 타일생성함수 꼴의 딕셔너리 정보이다.
          특정 게임맵에서 타일을 생성하거나 변경할 때는 이 타일셋에서 키를 입력해 타일생성함수를 반환받고, 그 타일생성함수를 실행하는 형태로 작동한다.

          이렇게 함으로서 이제는 서로 다른 지형에 대해 서로 다른 그래픽의 타일을 만들고, 동시에 id를 통일시킴으로서 게임 내적으로는 동일한 역할을 하도록 만들 수 있게 되었다.

          이 타일셋 값은 procgen의 generate_dungeon함수 초반부에서 초기화된다.

          4. 인벤토리 item split 관련 작은 버그 수정
          아이템을 split할 때 item state 정보만을 붙여넣기 하고 다른 값들은 초기 default 값 그대로 생성되는 바람에 split된 아이템의 gamemap정보가 None으로 초기화되는 문제가 발생해,
          여러 quaffable과 같은 컴포넌트 기능 사용에 문제가 있는 버그를 발견함.

          이를 inventory.split_item()에서 split된 아이템에 item_state정보를 복붙한 직후에 split item.gamemap값을 origin item.gamemap으로 초기화 함으로서 문제를 해결함.
          
          * 차후에 버그가 발생할 소지가 있음.

          5. terrain 내부에 방 형태와 사이즈 값을 추가함.

          기존 방 생성시에는 initialization에서 config값을 받아다가 해당 컨픽 내의 width, height범위에서 랜덤으로 뽑는 형식이었는데,
          이제는 각 terrain 별로 방의 크기의 범위와 가능한 방의 형태, 또 방 형태별 확률까지 조절 가능하게 만들었음.
20201002 - descend stair 대신 ascend stair가 스폰되는 버그(오타) 수정.

          1. actor_state 에 heal_wounds라는 불리안 변수 추가. 이 값이 True일 경우 actor_state.actor_heal_wounds()함수가 매 플레이어 턴마다 가동되어 constitution에 비례하는 값만큼의 체력을 회복한다.
          또한 이 함수가 가동되는 건 매 턴마다지만 쿨타임이 존재하기 때문에 매턴마다 무조건 체력을 회복하는 것은 아니다.
          이 체력회복 쿨타임 역시 constitution과 관련되어 결정된다.

          2. experience.py 작성.
          Experience라는 이 컴포넌트는 status.experience에 부착되는 (즉 컴포넌트에 부착되는) 컴포넌트로, 모든 액터들은 기본적으로 None, 즉 이 컴포넌트를 달지 않고 있는다.
          액터 오브젝트를 초기화할때 growthable이라는 불리안 값(기본값 False)이 주어지는데, 이 값을 True로 설정하게 되면 자동으로 초기화 시점에서 Experience 오브젝트가 status.experience에 새로 생성된다.
          따라서 플레이어나 펫과 같이 성장하는 모습이 필요한 엔티티들에게는 growthable = True로 설정해야 하며, 이 컴포넌트의 자세한 동작 방법은 별도의 텍스트 파일에 기술했다.
          Experience에는 현재는 어떤 초기값도 필요하지 않으며, 이는 달리말해 현재 엔티티 레벨이 1이던 100이던 growthable은 동일한 상태로 시작한다는 의미가 된다.
          이는 레벨업(스테이터스 증가)에 필요한 exp의 수치를 Experience 내에서 자체적으로 계산하기 때문이다.
          현재로선 일종의 테스트 개념으로 melee action에 exp의 증가 함수를 가동시키는 중이며, exp관련된 수식들도 전혀 정돈이 안되어있는 상황이므로 차후 게임벨런스를 조정하며 이 함수들의 조정이 필요하다.

          그외 자잘한 수정
          > status에서 lvl값 삭제
          > status에서 일부 함수명 오타 수정
20201005 - 새로운 액터 종류를 추가했는데 자꾸 알 수 없는 버그 나는 문제 해결. (원인은 정확히 파악하지 못함)
            > gamemap 정보가 None이라고 계속 뜨는데, 원인은 ai와 관련된 것으로 추정됨.
            > 해결법 : 다른 액터 종류와 ai가 중복되지 않게 해야함.
            > ai가 action을 상속하는 현재의 구조체계 자체를 바꿔봐야 할듯. 현재의 ai는 entity와 parent 값을 모두 가지고 있어서 다소 혼란스러움.

            1. 밀리 계산 시스템 정비
            > 각종 수식들을 사용해서 데미지 도출
            > 크리티컬 시스템 추가
            > 회피(miss) 시스템 추가
            
            2. 원거리 투척 시스템 정비
            > 투척 사거리 조정 -> 이제 사거리는 dex와 str의 영향을 모두 받음
            > 투척 크리티컬 추가
            > 투척 회피 시스템 추가
            > 투척 데미지를 base와 additional로 분리해서 다양성 추구
            
            3. actor state에 weight 변수 추가
            > 이 값은 차후 시체의 무게를 판정하는데 사용된다.

            4. 버그 발견
            > corpse 종류 아이템을 던질 경우 아이템을 복제하는 과정에서 에러발생.
            >> 해결방법은 stack_count가 1일 경우 애초에 split을 안하는 방법이 있을듯 함.
            >>> 생각보다 간단하게 해결되지 않는 버그임.
            > closed_door가 walkable이라 아이템을 던졌을 때 뚫고 지나가는 버그 존재.

            추가할 것
            > 버그 수정
            > 원거리 투척공격이 protection의 영향을 받게 만들기
20201006 - 굉장히 많은 부분들을 수정, 추가해서 누락된 사항이 있을 수 있음.

            1. take_damage함수를 실행하기 전에 실행해야하는 status 내의 calculate_dmg_reduction()함수 제작.
            > 이 함수에서는 데미지의 type에 따라 어떤 스테이터스 값을 어떻게 적용해 얼마만큼 데미지를 감소시켜야하는지에 대한 연산이 모두 처리됨.
            > 투척무기와 밀리무기 모두 physical 타입 데미지임.

            2. 스크롤 중심 대거 정비
            > 스크롤을 큰 종류별로 묶을 수 있는 부모 클래스를 작성함.
            >> 현재 작성된 건 RayReadable하고 AutoTargetingReadable 두가지로, 나머지도 작성이 필요함 (TODO)

            3. 그외
            > 일부 스크롤명 변경
            > magic_resistance값을 추가. protection값(not changed)도 마법타입 데미지 감소에 약간 영향을 주기는 함.
            > 매직미사일과 불 스크롤의 분류
            > 이제 메테오 스크롤은 범위에 불을 붙임
20201008 - equipable의 업그레이드 기능 정비.
           > 초기 스텟과 변경 스텟을 구분해서 딕셔너리 형태로 저장. (status와 유사한 방식)
           
           무기 타입의 equipable 제작.

           equipable에 힘 요구량 추가, 힘 요구량에 따라 보너스/마이너스가 주어지는 기능 추가.
20201009 - 메인 인풋핸들러에 modifier 키 입력 추가.
            > 이제 ability는 a키로 열고 close는 c키로, descend와 ascend는 각각 >와 <로 한다.
            > 또 Q키를 게임 종료 키로 설정함.
20201011 - cat, kitten, large_cat, fire_ant 추가.

            이제 모든 액터는 status에 difficulty 값을 가지게 된다. (플레이어는 None)

            근접 공격 시 상태이상 등 특수효과 부가 기능을 처리하는 melee_special_effects_on_target()함수를 action.MeleeAction에 추가함.
            > 이와 관련된 변수 두가지 -> effects와 effects_var를 추가함.
            > 주의해야 할 점 : 만약 특수효과가 즉각적으로 효과가 발현되는 것이라면 (ex.전기충격) melee_special_effects_on_target()함수에서 단순히 actor_state값만 바꿔줄 게 아니라,
              actor_state.actor_xxx()함수를 실제로 호출해 주어야함.
            >> 예를 들자면, 불 상태이상을 부여할 경우에는 actor_state.is_burning = [xxxx]만 해주면 되지만, 전기 상태이상을 부여할 경우에는 부여 즉시 효과가 나타나야 하므로
               actor_state.is_eletrocuting = [xxxx]해준 다음 라인에서 actor_state.actor_electrocute()를 실행해주어야함.
               자세한 사항은 volt_ant의 밀리공격을 참고할 것.
20201012 - 타일 정보의 flammable을 float로 변경. 이제 불이 잘 붙는 정도도 표현 가능해짐.

            confusion의 턴 확인 연산을 actor_state로 이동시킴.

            freezing, frozen 추가.
            > 디버그 필요 (agility가 1로 떨어지는 거에 더불어 플레이어가 못움직이게 해야함.)

            ice_elemental 추가.
20201014 - 버그발견 : actor_state를 표시할 때 한 템포 빠르게 표시되는 현상 발견.
            >  why? actor_state 변화 -> actor_state렌더링 (아직 스텟적용 안됨) -> 스텟 디버프 적용 
            >> 즉 actor_state 렌더링이 engine.render()함수 내에 있는데, 이 함수가 매 게임루프마다 돌아가서 그런거임.
            >>> 버그를 떠나서 효율성 문제를 고려했을때도 이 부분은 수정이 필수적임.\
            --> 수정 완료

            플레이어에게 confusion기능 추가
            > action with direction을 부모로 갖는 모든 액션은 영향을 받는다.
            > ai내의 confusion추가기능 삭제 고려중. (TODO) (삭제하지 않는다면, confusion상태가 걸려도 ai는 여전히 마법주문서를 읽거나 아이템을 장비하는 행위가 가능해짐.)

            freeze, frozen 상태가 겹치는 버그 수정.

            paralysis 추가. frozen 상태일 때 움직임 멈추는 기능 추가.

            confusion이 플레이어에게도 적용될 수 있게 만들음.

            기존 몬스터들의 상태이상은 ai.perform_frozen()이런식으로 perform함수를 별도로 분류함으로서 처리했는데, 이 부분을 이제 플레이어와 동일한 방식으로 처리하도록 변경함.
            > 구체적으로 말하자면, 이제 상태이상에 따른 행동제약은 action.py내의 함수 내에서 판정함.
20201015 - 몬스터 스폰 알고리즘 제작.
            > 많은 시행착오를 거치며 알고리즘을 제작함.
            >> 아직 벨런스 조정은 되지 않음 (추가된 몬스터 숫자가 충분치 않으므로)
            >> 벨런스 조정은 choose_monster_diffiulty함수를 변경하는 방식으로 조정할 수 있음.
            > 간단히 설명하면, 몬스터를 스폰할 게임맵의 층과 각 방에 스폰될 수 있는 몬스터의 최대 숫자를 입력받으면
              그 게임맵의 각 방 하나하나마다 다음과 같은 절차를 거치며 몬스터가 스폰됨

              > 이 방에 스폰할 몬스터의 숫자 결정 -> 스폰할 숫자만큼 다음 과정 반복

              >> 몬스터의 생성될 위치 결정 -> choose_monster_difficulty()를 통해 몬스터의 난이도 결정 -> spawn_monsters_by_depth()를 통해 실제로 스폰
            
              코드로 보는 것을 추천.

            몬스터 리스폰 기능 대거 수정.
            > 이제 몬스터 스폰 알고리즘에 의해 선별된 몬스터가 스폰됨.
            > 스폰되는 몬스터의 ai를 active 시킬지를 결정할 수 있게 만듬.
            > ai가 active되지 않던 버그 수정.

            해야 할 것들 : 포션 투척 시 효과 발생, 몬스터 리스폰 시 난이도 점차 상승
20201016 - floating eye 추가.
            > paralyze 추가
            > peaceful ai를 기반으로 움직이는 첫번째 액터 추가
            > 공격 받을 경우에만 특정 효과를 부여하는 기능 추가
	    
	    TODO : procgen의 tilemap 타일들 enum으로 깔끔하게 정리하기.
20201017,18,19 - 액셀 파일에 액터들의 구체적인 스테이터스 값 계획.
20201021 - 함정 추가
           > spike trap 추가
           > 함정이 일회성인지, 함정이 한 번 이상 작동했는지, 함정이 아이템과 액터 중 어떤 엔티티에 반응하는지 등을 조절할 수 있는 기능 추가

            rule 대거 수정
            > action 대신 basecomponent를 inherit하도록 제작
            > rule_factories 추가
            > self.entity 대신 self.parent 사용

            수정할 부분 - 함정의 작동방식 변경
            > 매턴 모든 함정이 엔티티를 확인하는 방식은 조금 무리가 있음.

            ai도 action 대신 BaseComponent를 상속하도록 구조 변경.

            현재 trap은 엔티티(세미액터)인데, 문제는 tilemap정보에 trap 위치도 저장된다는 거임. 즉 나중에 trap위치가 변해도 타일맵에는 여전히 trap의 위치가 저장되어있음. 이로 인해 버그가 발생할 소지가 다분함. 수정필요.
            > 수정 안해도 됨. tilemap정보는 어디까지나 플레이어가 상호작용하기 전의, 즉 게임 맵 생성 단계에서만 활용하는 정보이므로, 맵 생성 이후 플레이어가 영향을 미쳐서 변하는 맵의 변화에 대해서는 유동적으로 업데이트할 필요가 없음.
            >> 결국 타일맵 정보는 게임맵 생성 이후에는 사용해서는 안됨. gamemap.tiles를 사용할 것.

            tilemap 정보 내에 정수 입력을 완전히 enum으로 대체함
            > 이제 새로운 타일(혹은 지형 엔티티)의 추가를 쉽게 할 수 있음

            스크린샷 기능 추가
            > 현재 시각, 플레이어 이름에 맞춰 png파일로 저장함. tcod.save_screenshot 내장 메소드 사용.

            gui 일부 정비
            > render 관련 일부 함수에 draw_frame 키워드 추가. True일 때 하얀 테두리 상자를 그림.
            > 메세지 로그 창 높이 증가.
20201022 - 함정 관련 성능문제 해결
	   > rule을 매턴 가동하는 대신, 함정들은 엔티티의 move(), place()와 같은 함수가 작동할 때만 do_environmental_effects()함수를 가동함.
	   > do_environmental_effects()는 현재 해당 엔티티가 서있는 타일(혹은 세미액터)의 종류에 따라 어떤 행동을 할지를 결정함.
	   >> 해당 변경사항들로 인해 발생한 함정의 중복 데미지 문제 해결.
	   > 아직 아이템과 함정의 상호작용은 제대로 테스트가 안됨.
20201024 - ScrollOfThunder이 발동할 때 같은 타겟에게 두번 효과가 적용되는 버그 발견
            > 수정 시도했으나 원인을 찾지 못함.
            > status의 die()함수에 self.parent.gamemap.entities.remove(self.parent)를 가동시키기 직전에 try:문을 넣음으로서 임시조치는 취했으나, 차후 원인을 규명할 필요가 있음.

           handle_semiactor_turn() 함수 내의 rule에 previous_actor가 존재하지 않을 경우 나타나는 버그 수정.
           
           마우스 인풋 이벤트 틀 제작.

           pathfinding을 deque로 바꿀것. 속도 훨씬 향상됨.
20201025 - 마우스 인풋을 통한 이동 시스템 제작
            > 다양한 버그 수정
            > main함수의 구조 대폭 변경
            >> 다수의 함수가 engine.handle_world()라는 하나의 함수로 통합됨.
            > 문을 열 경우 열자마자 문 위로 이동하는(1턴을 추가로 획득하는 셈) 버그 수정
            > 경로를 몬스터를 피해 생성하는 기능 추가
            
            마우스 인풋을 통한 공격 시스템 제작

            TODO : brogue처럼 맵 상의 시야 내의 엔티티 자동으로 표시해주기 (?)
            TODO : 물약투척
            TODO : 허드 정리 (우측)
20201026 - 마우스 입력을 통해 이동할 때 시야에 새로운 액터가 등장하면 이동을 멈추는 기능 추가
          > engine.update_entitiy_in_sight()함수 제작. 매턴 시야에 들어오는 액터와 아이템을 업데이트함.
          
          마우스 인풋 관련 다양한 버그 수정
          > exeption(Impossible객체)이 출력이 안되는 버그 수정
          >> 예상치못한 exeption들은 출력할 수 있게(진짜 버그들) 수정
          > 클릭한 위치에 몬스터가 존재하면 path 생성이 안되는 버그 수정 (이제 몬스터가 있는 타일을 직접 클릭해 해당 몬스터가 있는 위치로 이동 가능)

          TODO : 한번도 탐험해보지 않은 지역도 길찾기 경로에 포함되는 버그 수정 (수정방법 : masking (numpy.ma)를 활용)
20201027 - semiactor관련 버그 수정
          > try문 관련 버그 수정
          > spend_action_point라는 이름의 벼수와 함수 모두 존재하는 버그 수정. 변수명을 do_action으로 변경함.
20201028 - 마우스 맵 화면 바깥을 클릭했을 때 오류발생하는 버그 수정
          스테이터스 hud에 base atk, add.atk 값 표시되도록 변경.

          TODO : 클릭으로 스크롤 cast 가능하게 만들기.

          우측 GUI 대폭 개선 (frame 제작, frame title 제작)
          > hunger bar 추가 시도했으나 overeaten 상태가 될 수 있다는 문제때문에 혼란을 야기할 가능성이 있어 취소
          > 상태이상 창은 이제 최대 12개의 상태이상을 표기할 수 있으며, 두 줄로 나누어 표기함. (사이즈를 늘리면 12개 이상도 가능)
          >> 만약 가능한 갯수를 넘어서면 창을 뚫고 나오기 때문에 주의
          >> 또한 아무 상태이상도 없을 경우 회색으로 None 표시
20201029 - 마우스 클릭으로 경로 생성 시 unexplored 된 타일도 경로에 포함시키는 버그 수정
          > 처음에는 모든 unexplored 된 타일을 완전히 경로에서 배제시키는 방식을 사용했으나, 이렇게 될 경우 누가 봐도 명확히 공간이 있는 타일인데 클릭해도 그 타일로 경로가 생성되지 않는 일이 발생함.
          >> 예를 들면 문 한칸 앞의 공간에는 타일이 분명 존재함. 그러나 그 타일은 문에 가려져 unexplored상태이므로 그 타일을 클릭해도 그 타일로 path가 생성되지 않음.
          >> 그러나 플레이어는 본능적으로 문을 누르기보다는 문 한칸 앞, 즉 자신이 가려고 하는 공간을 클릭함.
          >> 때문에 현재 사용중인 방식은, 클릭한 지점은 unexplored이더라도 cost값을 0으로 설정하지 않게 해 path에 포함될 수 있게 하는 방식임. (0이면 해당 타일은 지나가지 않음.)
          >>> 픽셀 던전에서 이런 방식을 사용하지만, brogue에서는 조금 다른 방식을 사용함. (정확한 알고리즘은 파악하지 못함)

          게임 시작 후 1, 2번째 마우스 클릭이 인풋은 인식이 되나 플레이어를 이동시키지 않는 버그 수정
          > 이는 prev_actor_in_sight랑 prev_items_in_sight가 None으로 초기화되어있는 반면에 actor_in_sight랑 items_in_sight는 set()으로 초기화되어있어서 발생한 일이었음.

          위에 기술한 버그 수정 후 첫번째 마우스 클릭이 한 칸만 이동시키는 버그 수정
          > 이는 첫번째 게임루프 시작 전 update_entitiy_in_sight를 실행하지 않아 일어난 일.
          >> update_entitiy_in_sight를 게임루프 시작 전 한 번 실행하도록 변경. 또한 update_entitiy_in_sight에 is_initialization 파라미터를 추가해, 해당 파라미터가 True일 경우 특수한 연산을 추가로 실행하도록 함수 수정.
          >> 이 파라미터는 오직 게임루프 진입 전 실행할 경우에만 True로 설정한다.
          

          add_message()함수에 target 파라미터를 추가함. 이제 메세지를 띄울때 간단하게 target값에 엔티티를 입력함으로서 해당 엔티티 위치가 visible일 때만 메세지 표시가 가능하도록 만들 수 있음.
          > 모든 add_message()함수에 target 추가.

          포션 투척 기능 추가
          > throwable에 break_calculation()함수를 추가. 이제 투척이 적중했을 경우 파괴될 확률을 계산한다.
          > throwable에 self.shattered 변수 추가. 이 변수는 오직 throwable의 break_calculation()에 의해서만 변경된다. 이 값이 True일 경우 throwable의 activate 함수 뒷부분에서 로그 메세지를 출력한다. (target은 thrower).

          엔티티를 삭제하는 기능이 필요한 경우 entity.remove_self()를 사용해야 하는데 그렇지 못한 부분들 수정.
          이제 모든 엔티티의 게임상에서의 삭제는 remove_self()를 사용한다. remove_self는 엔티티 종류별로 오버라이딩되어있다.
          단 remove_self는 메모리 상에서의 완전한 제거를 보장하는 것이 아님. 어딘가 reference가 존재해 메모리에 계속 남아있을 가능성도 있음. 이러한 가능성을 배제하기 위해 항상 주의해야함.
          > 수정완료. consume() 함수들과 액터 사망 할 경우 처리되는 연산을 remove_self로 변경.
          > remove_self()는 엔티티 종류별로 존재하는 함수. 이름은 서로 같지만 세부적인 연산은 다르다.
          > 불 semiactor가 꺼질때 삭제되는 연산을 remove_self로 변경.

          상태이상 창에 배고픔 상태 안뜨는 버그 수정

          TODO : 허기 상태가 될 때 플레이어 마우스 이동 중단하는 기능
20201102 - 마우스 pathfinding이 몬스터를 제대로 피해가지 못하는 버그 수정
          세미액터가 있을 경우 해당 타일을 경로에서 완전히 제거하는 기능 추가
          아이템 투척후 파괴 시 출력 메세지 문법오류 수정
20201107 - 문을 여는 기능 대폭 개선
          > dexterity에 확률이 영향받도록 조절
          > dex, int가 일정 이상이면 팔이 없어도 문 여는 시도가 가능 (ex. large cat)
          > 팔이 있다면 dex관계없이 문 여는 시도가 가능
          > dex가 낮거나 팔이 없을경우 str수치를 이용해 문을 부수거나 강제로 여는 기능도 추가

          아이템 투척 시 stack에서 투척할 때 발생하는 다양한 버그 수정
          > 아이템 투척 관련 코드를 다수 정리함
          > shattered 관련된 다량의 버그 수정
          > 아이템 stack을 통째로 던질 수 있는 기능 삭제, 이제 아이템은 한번의 throw 액션당 단 하나만 던질 수 있음.
          > 여전히 관련 코드들에 개선의 여지가 존재함. TODO
          > 구조 변경. 기존 target들을 리스트에 저장했던 방식 수정.

          potion of healing 관련 자잘한 버그 수정

          ai가 paralyze하는 동안에도 movementaction을 실행하고 path를 pop해서 마비가 풀리자마자 몇칸 순간이동 하는 버그 수정.
          > 이제 check_immobility는 ai의 perform에서도 실행한다.

          아이템 consume시 stack 전체가 삭제되는 버그 수정 (potion)
20201108 - (vscode 관련) pylance 사용. pylance를 사용하는 것으로 인해 semantic lighting이 true가되었는데 이를 다시 해제함.
           procgen의 generate_terrain 내부의 다양한 연산들 및 관련된 함수들을 terrain_generation.py라는 별도의 파일로 이동함.
           불필요한 import 전부 정리 완료
	        함정 소환 관련 함수 일부 수정
20201109 - 중독 상태이상 추가
            > giant wasp 추가
            > 독성이 constitution을 매 턴마다 반으로 깎는 효과 추가
            > 버그 발견 : constitution이 원 상태로 복귀되지 않는 버그 존재
            >> 수정완료

            TODO : 보너스 수치와 기본 수치를 스테이터스 GUI에 별도로 표기하기 15(+3)
            >> 혼란을 줄 소지가 다분해서 GUI에는 오직 최종 수치만을 표기하는 것으로 결정함.
            TODO : Mad 상태이상을 추가함으로서 ring of conflict같은 아이템 추가될 수 있는 기반 작성하기
20201110 - 계단 생성 관련 중대한 버그 해결
            > 기존에는 tunnel_between함수를 사용해 계단 사이를 잇고, 경로가 있는지 확인했는데, 여기서 간과되었던 문제가 바로 void의 존재임.
            >> 때문에 tunnel_between함수를 path_between함수로 변경함. 이 함수는 cost값을 받아 그 cost를 기반으로 경로를 생성하는데, cost가 tunnelmap이면 기존의 tunnel_between과 동일하게 작동함.
            >> 일반적인 경로찾기의 경우 cost를 tiles["walkable"] 값을 전달하면 됨.
            > 또한 기존의 try except와 next를 사용하던 방식 대신 path_between의 모든 경로를 iterate하는 방식을 채택함.

            확실하진 않은데 불데미지(직접 화염데미지 말고 잔류 화염 데미지)로 ai가 죽으면 에러 발생하는 경우가 있는듯 함. 해결필요 (voltant와 fireant가 싸울때 발생했음)
            > Traceback (most recent call last):
              File "c:\Users\user\Desktop\Geophyte_tcod\ver22\ver22\main.py", line 57, in main
                engine.handle_world(turn_pass=turn_pass)
              File "c:\Users\user\Desktop\Geophyte_tcod\ver22\ver22\engine.py", line 78, in handle_world
                self.handle_enemy_turns()
              File "c:\Users\user\Desktop\Geophyte_tcod\ver22\ver22\engine.py", line 105, in handle_enemy_turns
                entity.ai.perform()
              File "c:\Users\user\Desktop\Geophyte_tcod\ver22\ver22\components\ai.py", line 79, in perform
                return self.perform_hostile()
              File "c:\Users\user\Desktop\Geophyte_tcod\ver22\ver22\components\ai.py", line 420, in perform_hostile
                return self.get_melee_action(dx=dx, dy=dy)
              File "c:\Users\user\Desktop\Geophyte_tcod\ver22\ver22\components\ai.py", line 167, in get_melee_action
                return MeleeAction(self.parent, dx, dy, self.melee_effects, self.melee_effects_var).perform()
              File "c:\Users\user\Desktop\Geophyte_tcod\ver22\ver22\actions.py", line 522, in perform
                damage = self.damage_calculation(crit_multiplier=crit_multiplier)
              File "c:\Users\user\Desktop\Geophyte_tcod\ver22\ver22\actions.py", line 466, in damage_calculation
                size_bonus = (self.entity.actor_state.size - self.target_actor.actor_state.size) * 0.15
              AttributeError: 'NoneType' object has no attribute 'actor_state'
            > TODO

            AI 대대적인 개선.
            > AI의 기존 분류 체계 변경.
            >> peaceful, neutral, hostile, allied, pet의 5가지 alignment 값으로 변경, 또한 각 alignment값은 str형태로 ai 인스턴스에 저장됨.

            > AI를 하나로 통합
            >> HostileAI, HOstileToPlayerAI등으로 상속을 통해 분류하는 대신 BaseAI에서 모든 기능에 접근 가능하도록 통합함.
            >> 이로써 AI의 성향(alignment)을 게임 도중 바꾸는 게 쉬워졌음.

            > AI의 선태적 타겟팅 기능 추가
            >> hostile 한 ai의 경우 자신이 적대시할 엔티티의 id, 혹은 타입, 혹은 액터 인스턴스 자체를 설정해놓을 수 있음
            >> allied한 ai의 경우 위와 동일하지만 적대시 대신 동맹관계로 삼을 수 있음
            >> 즉 기존 hotileToAll ai를 구현하려면 allied alignment를 선택한 후 동맹에 아무도 입력하지 않으면 됨.
            >>> 그러면 모든 액터를 적으로 삼기 때문에 결과적으로 동일한 역할을 하게 할 수 있음.
20201111 - Throw 기능이 있는 첫번째 인게임 몬스터 추가 (black jelly)

           Throwable의 효과가 발동될 때 투척데미지로 인해 사망한 엔티티에게도 효과를 적용하던 버그 수정.
20201112 - Toxic Goo를 현재로서는 무한히 제작할 수 있음. 수정 혹은 개선 필요. (dodge했을 경우 shattered되지 않고 그냥 드랍됨)
          함정을 밟았을때의 효과를 walkable이라는 별도의 컴포넌트로 분류함.
          > Rule은 어디까지나 AI의 역할을 하고, walkable은 밟았을 경우 일어나는 효과를 담당함.
          > wlakable은 모든 엔티티에게 부착할 수 있으며, 따라서 아이템을 발았을 경우 발생하는 효과 등도 제작할 수 있게 되었음.

          함정 관련 버그 발견
          > A 엔티티가 함정을 밟을 경우 다른 B 엔티티가 같은 함정을 와서 밟아주기 전까지는 함정효과가 두번 이상 발생하지 않는 문제 발견
          > 생각해보니 기존에 engine에서 이미 handle_semiactors_turn()에서 previous_actor을 초기화하는 방식으로 이 문제를 해결한 적이 있었음.
          >> 수정완료
20201114 - 몬스터 생성 알고리즘이 정규분포 그래프를 따르도록 변경.
            > 상수값으로 변경 및 플레이어 스텟이 영향주도록 변경 필요.

            스테이터스, 전투 연산 관련 대거 수정
            > protection 값을 모든 유닛들에 대해 2배가량 상승시킴.
            >> 이로써 갑옷 등 보호도를 더욱 세부적으로 분류할 수 있게 되었음
            > 이제 힘 수치는 갑옷 관통력 및 근접 데미지에 영향을 줌.

           물, 구덩이 생성 관련 기획
           > Deep pit, Shallow pit 두 단계로 나눈다. 물은 Deep Pool of water, Shallow pool of water 두 단계로 나눈다.
           > 물은 세미액터 취급하며, 부피에 따라 2, 1, 0 세 단계로 나눈다.
           > Deep pit + 물2 = Deep Pool Of Water
           > Deep pit + 물1 = Deep pit
           > Shallow Pit + 물2 = Shallow Pool of water
           > Shallow Pit + 물1 = Shallow Pool of water
           > 물 0은 구덩이에 넣더라도 바로 증발.
           > 평지 + 물2 = 물1로 번짐
           > 평지 + 물1 = 물0으로 번짐
           > 평지 + 물0 = 증발

           구덩이 타일 제작
           > 구덩이 탈출 관련 함수 제작, 탈출 확률은 size와 dexterity에 영향받도록 함.

           TODO : add_message에 importance라는 파라미터를 주어서 필요에 따라 중요한 로그만 프린팅 가능하도록 하는 기능 추가
           TODO : 구덩이(구멍말고)가 있는 지형 추가
           TODO : 구덩이 활용해서 물 세미액터추가, 물 지형 추가
20201115 - terrain_generation 관련 함수 다량 변경
            > gen_grass, gen_water 딕셔너리 내의 파라미터값을 3개로 축소시킴.
            > gen_traps 관련 기존에는 튜플로 함정들의 종류를 전달했는데, 이제는 딕셔너리를 사용해 함정의 종류 및 각각의 확률까지도 전달함.

            바둑판 형태로 두 종류의 타일을 임의의 공간에 번갈아가며 놓을 수 있는 알고리즘 발견, 별도로 기록해둠.
20201116 - 물 지형 생성 관련 변경
            > 기획: 물 밟은 지점 및 그 주변만 색깔변하게 하기?
            > 기존 계획은 구덩이를 파고 그 위에 물을 세미액터로서 소환할 생각이었으나, 문제가 너무 많은 방식이기 때문에 물 역시 하나의 타일로 취급하는 것으로 변경함.
            > 깊은 물 주변에 얕은 물 생성하는 시스템 제작

            물 타일 추가
            > 얕은물과 깊은 물 두종류 추가
            > bg randomize되는 기능 추가
            > 엔티티가 밟았을 때 주변 칸들까지 그래픽이 새로 변하는 기능 추가 (brogue처럼 상시 색상변경하기에는 속도에 무리가 있음)
20201120 - 타이틀 화면에서 마우스 입력에 따라 애니메이션속도가 좌우되는 버그 수정.
            > 상당히 오래 걸림...
            > 여전히 마우스를 움직였다가 멈추면, 혹은 키보드를 아주 빠르게 연속적으로 입력하면 일시적으로 속도가 느려지는 현상 존재. 아주 미미하지만 (약0.5초) 여러 프레임에서 지속적으로 일어날 경우 축적되어 문제가 될 수 있음.
            >> 원인발견 : tcod.event.wait()의 timeout이 문제였음. timeout에 작은 숫자 (0.01s) 를 넣으면 이러한 속도가 느려지는 현상을 거의 체감하지 못하는 수준으로 낮출 수 있음.

            ability, ai 관련 대폭 개선.
            > 몬스터가 마법 및 능력 사용하는 기능 추가중.
            >> 일단 조건 판정하고 시전하는 것 까진 구현 완료.
            > ability.on_activation을 통일성 문제때문에 activatable로 명칭 변경.
            > 기존 do_ranged_attack에 ability까지 통합한 시스템에서 use_ability로 분류함.
            >> check_is_use_ability(?이름 비슷함) 함수 제작 및 get_ability_action함수 제작.
            
            특정 대상에게만 hostile한 ai에 대해 문제발견
            > 공격받아도 주어진 범위 밖이면 보복을 아예 안하는 문제발생 버그 수정필요.

            TODO : 일단 만들던 nymph의 steal 어빌리티 만들기.
            >> Done
            TODO : ai는 현재 마나가 부족하면 알아서 마법 사용을 멈추고 다른 액션을 취하는데, 혹시라도 마법 사용이 강제되는 경우가 있을 수 있으니 activatable의 cast() 함수 자체 내부에 마나가 부족한 데도 cast가 실행되는 경우에 대한 대비책 제작 필요.
            >> Done
20201121 - activatable, AbilityAction 관련 대거 수정
            > dx, dy를 direction으로 전달하는 대신 x, y를 coordinate로 전달하는 것으로 방식 변경,
            > 이제는 target정보를 직접 전달함.
            > 방향이 없거나 타겟이 없을 경우 None을 대신 전달함.
            
            steal 제작
            > 버그 발견 : 갑옷을 훔쳐간 경우 장착해제가 안되는 버그
            >> 훔칠 때 강제로 탈착시키도록 기능 추가
            > 버그2 : 플레이어가 "장착한" 갑옷을 훔쳐갈 때 사라지는 버그. 장착 안한 상태의 아이템이면 안사라짐. 이상한 점은 칼에는 이런 버그가 발생을 안함.
            TODO : 버그2 수정 <완료>
            TODO : 메세지 창에 importance 파라미터 전달하는 기능 추가
            TODO : 일반적인 로그(color.gray나 color.white인 로그들)들에 대해 target이 플레이어면 자동으로 색상 배정해주는 기능 추가
20201125 - 계단이 함정이 있는 위치에 생성될 경우 생기는 버그 수정
            > 아예 계단이 아무런 엔티티가 없는 곳에만 생기도록 코드 수정.

            status.die()에서 아이템 드랍할때 버그 있는 것 발견
            > steal에서 자꾸 버그가 나는 것도 이것때문이었음.

            아이템의 duplicate_self() 대거 수정
            > item_state의 get_state, set_state 삭제
            >> 대신 이제 엔티티 자체의 메소드로 get_info, set_info를 제작했으며, 이 함수는 엔티티와 관련된 모든 정보의 전달 및 수신을 담당함.
            > corpse를 뺏어갈 경우 corpse의 기본 형태를 item_factories에서 스폰하는 기존 방식은 corpse의 이름, 영양정보나 부패상태 등을 제대로 복사하지 못하는 문제가 있었음.
            > duplicate_self함수를 수정하며 이러한 문제 해결.

            문 갯수 설정관련 버그 해결
            > terrain은 이제 door_num을 입력받는 대신 door_num_range와 weight를 입력받음.
20201127 - tile_types에 safe_to_walk 불리안 파라미터 추가.
            > engine.generate_path에서 플레이어가 마우스로 클릭해 경로를 생성할 때 위험한 길은 경로에서 제외하는 기능 추가함.
            > TODO : 이 기능은 ON/OFF할 수 있는데, 플레이어가 이를 조정할 수 있는 일종의 옵션창같은거 추가할것.
            > TODO2: 마찬가지로 새로운 몬스터가 등장했을 때 멈추는 것도 플레이어가 조정할 수 있게 할 것.

            semiactor에 safe_to_move 불리안 파라미터 추가.
            > 이제 플레이어 및 몬스터는 모든 세미액터를 경로에서 피하는 게 아니라 일부 위험한 세미액터들만을 경로에서 배제함.

            AI가 위험한 타일을 피해가는 기능 추가, 또 플레이어도 자동경로 생성시 위험한 타일을 피해가는 기능 추가. (플레이어와 AI가 이를 handle하는 방식이 서로 많이 다른 점 유의할 것.)
            1.
            > AI의 경우, 처음엔 위험한 타일을 절대 경로에 포함시키지 않는 방식을 채택함. 그런데 이 방식을 쓰게되면 AI가 경로 자체를 만들지 못해서 같은 위치에 가만히 서있는 문제가 발생함.
            > 그래서 수정한게 cost값을 높이는 방식임. 이제 AI는 정말 어쩔 수 없이 위험한 타일을 지나가야 할 경우에는 위험한 타일(혹은 세미액터)도 경로에 포함시킴.
            
            > 반면 플레이어의 경우에는 (플레이어가 설정을 통해 위험한 경로도 경로생성에 포함되도록 바꿔놓은게 아닌이상) 위험한 타일 및 위험한 세미액터가 있는 곳을 절대로 자동경로 생성 시 경로에 포함하지 않음.

            2.
            > 현재 자신이 위험한 타일 위에 있다면 자동경로 생성시 (원래라면 위험한 타일을 모두 경로에서 배제할텐데) 자신이 서있는 타일과 같은 종류의 타일은 위험하더라도 경로에 포함하도록 코드를 수정함.
            >> 이렇게 하는 이유: 예를 들어 플레이어가 깊은 물로 둘러쌓인 물웅덩이 한가운데 텔레포트되었다고 가정하자. 그러면 만약 수정이전의 방식을 유지했을 경우 물웅덩이 바깥을 클릭해도 모든 물웅덩이는 경로에서 배제되기 때문에 경로 자체가 만들어지지를 않는다.
            >> 반면 수정이후의 방식에서는 물웅덩이 타일들도 전부 경로에 포함시킴으로서 바깥을 클릭할 경우 물웅덩이 + 안전한 타일들로 구성되어있는 경로를 형성한다.

            님프의 steal을 black jelly한테 쓸때 blackjelly의 toxicgoo는 무한히 사용해야하므로 itemcount가 -1로 설정되어있는데 여기서 문제 발생.

            물에 잠기는 판정 및 익사 시스템 추가.

            BUG : 맵의 0,0지점에 toxic goo가 떨어져있는 버그 발견. 원인은 불명.
            TODO : 맵 테두리 undiggable한 타일로 제작
            TODO2: 터널에 불규칙성 추가하는 파라미터 제작
20201207 - 문의 세미액터화 완료.

            모든 엔티티에 대해 ray tracing 적용되도록 변경.
            > 생각보다 performance issue가 심각하지 않았음.
            > 이제 모든 엔티티의 하위 클래스들은 blocks_sight 파라미터를 추가로 가짐.

            어떤 객체를 세미액터로 만들지, Tile로 만들지 애매한 경우 판정법
            > 만약 해당 객체로 BumpAction했을 경우 특정한 일이 발생해야 한다면 세미액터로 만든다. (ex. 문)
            > 만약 해당 객체 위치로 이동해도 아무 일도 없거나, 혹은 객체를 밟았을 경우 아주 간단한 효과가 발생하는 경우에는 타일로 만든다. (ex. 잔디, 물)
            > 만약 해당 객체가 움직일 수 있는 경우에는 세미액터로 만든다. (ex. 불, 함정)

            >> 결론) 좌표상에서 움직일 일이 아주 적고, 충돌에 의한 효과가 없는 경우 전부 Tile로 제작한다.

            chest 세미액터 제작중.
            > 일단 충돌 시 특정 액션을 perform하는 기능까지는 제작함.
20201208 - chest 세미액터 제작 완료.
            > GUI 추가.
            > 아이템 take하는 기능 추가.
            TODO : 아이템 집어넣는 기능 추가하기.
            
            인벤토리의 sort와 관련된 문제 해결 (items만 sorting하고 hotkeys를 정렬 안하는 문제 해결.)
            TODO : AbilityInventory의 Sorting 제작하기.
20201210 - 맵 경계 타일 제작.
          
          버그 다량 발견
          > 1. 물이 no border일 때 문 위에 생성되는 버그. <O?>
          >> 해결. terrain_generation.adjust_obstacles 함수를 제작함.
          >>> 해결된 줄 알았으나 아주아주 간혹 이러한 현상이 발견됨. 5번 버그와 관련이 있을 수도 있음. 원인불명.
          >>>> 5번버그 수정 이후에는 이러한 현상이 목격된 적 없음.
          > 2. 마우스로 이동할 경우 문 열기에 실패했음에도 문을 뚫고 지나가는 버그.
          >> 해결.
          > 3. 몬스터 리스폰과 관련된 버그. (정확히 파악못함 아직)
          >> 보류. 모든 difficulty에 몬스터가 추가된게 아니라 발생하는 문제일 가능성이 높음.
          > 4. no border가 맵 경계까지 뚫고 나가는 문제
          >> 일단 해결. 단 맵 경계를 뚫지는 않아도 맵 경계가 보일때까지 확장하는 건 고치지 못함.
          >>> 수정할 방법 제안) border를 2겹으로 만들기. 단 한 겹은 타일을 일반적인 wall로 해놓는거.
          > 5. 이미 문이 있는 위치에 또 문이 생기는 버그 발견.
          >> 해결.
          > 6. 과거에 발견했던 버그 : 아마 원인은 volt ant의 전기공격에 있으리라고 추정됨.
          >> 해결..? 밀리공격 시 특수효과 부여 순서를 기본 밀리데미지 이후로 미룸으로써 버그 수정. 또한 특수효과 부여하기 전에 공격대상이 밀리공격데미지에 의해 사망했는지를 확인하는 라인을 추가함으로써 remove_self()된 객체를 타겟으로 삼지 않도록 변경.(수정했다고 추정)
          > 7. 물에 들어갔다 나왔을 때 디버프(dex, agi)가 계속 유지되는 버그
          >> 해결.


          그 외
          > explored 한 지역의 tile name이 보이도록 변경. (기존에는 visible area만 보였음.) 단 entity name은 visible일때만 보임.
          > drowning을 물에 들어간 순간부터 표시되도록 변경, 또 익사 턴이 얼마 남았는지도 표시.

	  버그 추가발견
	  > 창고에 아이템을 초기화할 때 모든 창고가 동시에 초기화되는 문제 발견.
	  > 창고에서 가져온 아이템은 사용 시 문제가 발생.
20201214 - 창고 관련 버그 두가지 다 수정.

            게임 세이브할 때 context, console None으로 바꾼 후 다시 값 설정해주는 기능 제작. (이게 없어서 세이브 직후 스크린샷 찍으면 버그가 발생했음.)
20201215 - engine.remove_duplicates 대신 list(set(self.entities))로 코드변경.
20201220 - 상자 생성 시스템 제작.
            > generate_chest와 grow_chest 함수 제작.
            > terrain에 gen_chest 파라미터 제작. 여기서 상자에 어떤 아이템을 얼마만큼의 확률로 넣을 지 지정가능.

            함정이 물 위에 생성되는 버그 해결.
            > 문자열 슬라이싱 활용해 id 끝 네자리가 door 혹은 trap일 경우 삭제.

           상자 생성 관련 구조적 변화
           > 기존에는 상자 생성과 상자 스폰이 기존에는 하나로 합쳐져있었음. (gamemap의 초기화 시점으로 인해 발생하는 아이템의 사용불가 문제 때문에)
           > 그러나 이제는 상자 생성과 상자 스폰은 별도의 함수임. (액터의 인벤토리 초기화와 유사한 방식을 사용함.)

           상자, 액터의 초기화 과정 대폭 수정
           > 액터의 경우 기존에는 initialize actor라는 별도의 .py 파일 내의 initialize_actor을 통해 초기화했는데, 이제는 Actor.initialize_actor() 메소드를 통해 초기화함.
           > 또 액터 클래스 자체에 initial_items, initial_equipments, initial_abilities 파라미터를 추가함으로써 액터와 관련된 자료는 전부 액터 내에 저장되도록 더 나은 구조로 변경함. (기존에는 initialize_actor.py 안의 initialize_actor에 별개의 데이터베이스를 저장해뒀었음.)

           갑옷 장착 중에 던질 수 있던 버그 수정

           magic mapping의 경우 initialize_actor()로 초기화했을 떄 사용 후 stack에서 갯수가 줄어들지 않는 버그 발견.
           > 버그 발생했다 안했다 함. 발생조건은 불명.

	         engine.remove_duplicate가 sorting 뒤에 나옴에 따라 sorting이 무의미해지는 버그 수정. (remove_duplicate()가 sort_entities()내에서 호출되는 순서만 앞으로 당김)
20201221 - Input 관련 구조 대거 수정.
            > 조금 더 클래스를 유기적으로 연결함으로써 여러차례 복붙되는 코드가 없도록 변경함.
            
            상자에 아이템 넣는 기능 추가.

            버그발견: 물건 던졌을 때 창고 세미액터와 충돌안하는 버그 (문도)
            > 수정 완료.
            >> 닫힌 문에 아이템 던졌을경우 아이템이 안깨졌다면 문을 열게 됨. (픽셀던전하고 흡사)

            어빌리티 Enum 제작, ability_type 추가

            플레이어도 initialize_actor() 가동하도록 만듬.
            > procgen의 generate_entities에서 만약 현재층이 1층이라면 (즉 게임을 이제 막 시작해서 처음 맵이 생성되는 중이라면) 가동함.

            버그발견: 플레이어의 어빌리티 사용관련 치명적인 버그 (구조적인 문제임.)

            버그발견: 장착한 갑옷을 상자에 넣을 수 있는 버그.
            > 지금 보니까 장착한 아이템이 이동될때 버그발생이 일어남 계속. 앞으로 유의해야할듯.
            >> 해결.
20201228 - ability의 구조적 문제 해결. 생각보다 큰 문제는 아니었음.
20210104 - electrical 데미지 대폭 개선.
          > 이제 데미지는 인접한 액터 뿐만 아니라, 연결된 모든 액터들에게 다 적용됨. 연결된 액터들을 구할 때 BFS나 DFS를 사용할 수도 있지만 대신 재귀함수를 통한 다른 방법을 사용함.
            > 또한 데미지는 전기 발생 장소로부터의 거리에 따라 감소함. 
            (기존 계획은 액터 한 명을 거칠 때마다 전기의 세기가 약해지는 방식으로 할려고 그랬는데, 이 방식을 구현하려면 BFS 사용이 필수적이어서 chebyshev거리를 계산해 그 거리에 따라 데미지를 감소시키는 방법을 사용함
            다행히 이 방법을 사용해도 계산 결과값은 변하지 않음.)
20210107 - AI 구조 대폭 개선.
          > AI가 타겟이 시야 밖으로 사라지자마자 추적을 포기하는 문제 해결.
          > AI는 이제 매 턴마다 시야를 갱신하며 쫓아옴.
          >> AI의 시야를 매번 생성하는 형태에서 AI 자체에 저장하는 형식으로 변경.

          SelectTileReadable 추가.
          > Confusion은 이제 SelectTileReadable을 상속함.

          Scroll of Tame 추가, 펫 기능 제대로 추가.

          펫이 플레이어 이외의 액터도 주인으로 섬길 수 있도록 구조적 변경.

          버그 : 펫이 문 밖의 적도 타겟팅하는 문제. >> 해결
          > 원인: ai.update_vision()에서 문과 같은 blocking entities들을 연산에 포함시키지 않아서
          버그2 : SwapPlaceAction이 잘 안됨. >> 해결
          버그3 : 원거리공격 및 일부 ability가 ai에서 호출이 안되는 문제 >> 해결
          > 원인: ai.get_ranged_direction에 액터 확인 기능에 range(distance)를 range(1, distance)로 변경해서 해결. range가 0에서 시작하다보니까 dx*0, dy*0을 체크하면서 자기 자신은 friendly로 판정하다보니 발사/마법캐스팅자체가 안된거였음.

          TODO: 펫 너무 멀리 가는 것 방지하기 위한 명령들 추가 (ex. go kill everything / protect me / stay with me 등)
          TODO: 상자 세미액터가 길막하는문제 방지
20210108 - Scroll of enchantment 제작. 이 스크롤에 필요한 별도의 인풋핸들러 InventorySelectItemAndCallbackHandler 제작. 파이프라인 구축하는게 생각보다 훨씬 힘들었음...
          > 참고: InventorySelectItemAndCallbackHandler가 실행될 때 일어나는 일
          readable.get_action()에서 event_handler을 InventorySelectItemAndCallbackHandler로 변경.
          게임루프 종료, event_handler 실행 (인풋대기)

          다음 게임루프에StorageInputHandler의 ev_keydown() 호출
          StorageInputHandler의 on_item_selected() 호출
          callback(self.selected_item) 호출 (=actions.ReadItem(... , selected_item) 객체 반환)
          callback(self.selected_item)종료. 반환된 객체는 actions.ReadItem.
          on_item_selected()종료, 반환된 객체는 actions.ReadItem.
          ev_keydown() 종료, 반환된 객체는 actions.ReadItem.
          <---- 끝 ---->

          StorageInputHandler에 아이템 필터링 기능 추가.
          > 이제 아이템을 필터링하려면 StorageInputHandler의 show_only 파라미터에 튜플값으로 보여주고싶은 아이템들의 Enum을 전달하면됨.
          >> 활용예시 - 강화 스크롤을 읽을 때는 강화가 가능한 아이템만을 보고 또 선택할 수 있게 해야함.
          > 아이템 필터가 걸렸을 때 인벤토리 창의 크기도 표시가능한 아이템 수에 맞게 축소하는기능 추가.

          업그레이드 기능 추가. (기존에도 있긴 했는데 자잘한 버그들 수정해서 정상작동하도록 만듬.)

          PlaceSwapAction은 이제 액터 - 액터 뿐아니라 액터 - 엔티티도 지원함.
          > 상자가 길막하는 문제 해결.
20210115 - github에 리퍼지토리 등록.
20210117 - BUC 추가, Identification 추가.
            > Scroll of Remove Curse와 Scroll of identify 추가
            > 아이템에게 initialize_item() 메소드 추가, 이제 아이템의 초기 BUC와 Identification을 확률과 함께 설정할 수 있음.

            BUC, Identification 관련 StorageEventHandler의 on_render()함수 수정.

            StorageMultiple, Single SelectEventHandler의 공통부분을 부모클래스로 통합함.

            Identification 세분화 - full, semi, none으로.
            > full은 BUC까지 다 아는 상태
            > semi는 아이템 이름만 아는 상태

            인풋핸들러의 스토리지 출력 필터링 기능 세분화
            > 어떤 아이템만을 출력할지 보다 더 세부적으로 조정할 수 있게 되었음.

            크고 작은 버그 수정.

            item_state에 identify_self() 를 추가해서 다양한 상황에서 쉽게 identify가 가능하도록 구조적 변경.
            
            한 번 감정(semi-identify)된 아이템은 이후 게임 내내 감정된 상태(이름이 표시됨)로 나오는 기능 추가.
            > item_state에 check_if_semi_identified()와 check_if_full_identified()를 추가
            > item_factories에 item_identified 딕셔너리 추가
20210118 - 아이템 랜덤화 기능 추가. 이제 아이템은 정통 로그라이크처럼 랜덤한 형태와 이름을 가지고 스폰됨.

          Item manager.py 추가.
          Item list, item identification list를 Item manager 안으로 옮김.
          entity의 char, fg, bg, name, entity_desc 값을 프로퍼티화해서 조건에 맞는 값을 리턴하도록 제작함.
          > 아이템은 랜덤으로 정해진 색상 혹은 이름을 출력하며, 만약 감정된 상태일 경우 원본 이름 혹은 설명을 출력함.
          
          그외 자잘한 버그 수정.
20210119 - 버그 수정.
20210120 - 아이템을 사용할 경우 identification이 자동으로 되는 기능 추가.
          > item_state.identify_self() 함수와 별도로 item_manager.identify_type()함수를 제작함.

          주문서와 같은 사용 후 플레이어의 인풋을 받는 아이템의 경우, 한번 사용하고 취소하면 아이템이 사라지도록 변경함. (다른 로그라이크들에도 존재하는 기능임. 아이템을 아무 댓가없이 감정하는 것을 방지하기 위함.)
          > revert_callback()함수를 get_action에 넘겨주는 방식으로 동작함.
          > 생각보다 상당히 추가하기 어려운 기능이었음.. 
            재귀적으로 콜백함수를 호출하는데다가, 콜백 호출 전에 유저로부터 확인인풋을 또 받아야 하기 때문에 구현하기가 여간 쉽지 않았음.

          >> 1. ~able.get_action()에서 자기자신(get_action())을 input_handler에 revert_callback()으로 넘겨줌.
          >> 2. input_handler에서 만약 esc 등을 눌러 행동을 취소했을 경우, 사용자에게 다시 정말 행동을 취소할 것인지를 물어보는 ItemUseCancelHandler로 넘어감.
          >> 3. 사용자가 취소를 confirm하면 ItemUseCancelHandler에서 앞서 전달되었던 revert_callback(cancel=True)을 실행함.
                사용자가 취소를 취소하면 revert_callback(cancel=False)를 실행함.
          >> 4. revert_callback()에서 cancel 파라미터로 받은 값에 따라 InputHandler를 다시 실행하거나 (cancel=False일때), 
                혹은 아이템을 consume하고 WaitAction을 반환해 턴을 소모함. (cancel=True일때)
20210121 - 메세지창을 띄우는 메소드 제작 (engine.draw_window).

          세이브, 아이템 사용 취소 시 로그에 메세지를 표시하는 대신 메세지 창을 띄우도록 변경.

          TODO : 타이틀 애니메이션 수정

          dog, puppy, large dog, gelatinous cube 추가.

          Engulfing 뼈대 제작
          TODO: equipments들이 물 위에 드랍되었을때 그래픽이 깜빡이는 버그 발견.

          밀리특수효과를 처리하는 함수를 engine으로 이동
          > 이제 밀리 뿐만 아니라 액터에게 특수효과를 부여하는 모든 연산은 이곳에서 담당함.
20210128 - engulf 기능 삭제. 아직 구현할 단계가 아니라고 판단되어 삭제함.
        
          acid 상태이상 추가.

          nymph는 이제 인벤토리가 가득 차지 않았을 때만 steal 기술을 시전함.
          > 또 님프의 최대 인벤토리 capacity를 1로 변경.

          TODO: 훔치고 도망가도록 ai 변경
20210220 - 특정 층에 특정 리스트의 biome중에서만 하나 선택해 생성하는 시스템 추가.
          특정 biome에 특정 리스트의 terrain 중에서만 하나 선택해 생성하는 시스템 추가.

          이제 던전을 층별로 분류할 수 있게 되었으며, 각 바이옴별로 특정한 지형들만이 나타나도록 할 수 있게 되었음.

          visible entities를 보여주는 GUI 기능 추가.
          > engine.actors_in_sight랑 items_in_sight 관련한 자잘한 버그 수정.
          
          locked door 추가, unlock 액션 추가.
          모든 아이템들은 이제 lockpickable 수치를 가짐. (얼마나 자물쇠따기에 효율적인지를 나타내는 척도)

          chest, door과의 interaction관련해서 어떻게 방안을 찾을것.
          > door는 턴이 언제 지나는지, 또 어떤 식으로 상호작용할 지 명확하지 않음.
          > chest는 ai가 실수로 열지 못하게 막아야 함. ai와 나 사이에 상자가 있다면 ai는 swap대신 상자를 열려고 시도하기 때문에 이를 해결해야 함.
20210221 - 현재로썬 플레이어가 스스로 doorbreakaction 혹은 doorunlockaction을 할 수 있는 방법이 없음. 이를 해결할 것.
          또 몬스터의 doorbreakaction 파트가 디버깅이 안되어있음.

          두 세미액터가 같은 위치일 경우 BUmpAction이 불가능해질때가 있는 버그 발견. (ex. 문과 창고가 겹칠 때 창고와 swap할 수 없음)
          >> 수정. BumpAction을 가지고 있는 세미액터를 우선해서 반환하는 함수 추가.
          
          두 세미액터가 같은 위치일 때 렌더링 순서가 꼬이는 경우 발생.
          >> 수정. semiactor_obj라는 새로운 RenderOrder Enum 추가.

          TODO: 문 종류마다 파괴 가능여부를 기록해야함
          TODO2: 잠긴 문이 던전에 랜덤하게 생기게 해야함.
20210223 - (임시) 게임 엔딩 제작
            Amulet of Kugah 제작

            entity에 indestructible 프로퍼티 추가. 해당 프로퍼티가 참일 경우 해당 엔티티는 remove_self()로 제거되지 않는다.
            > indestructible키워드의 남용은 오류 발생 위험이 있으므로 amulet of kugah와 같이 특수한 경우를 제외하고는 최대한 사용을 자제하는 게 권장된다.

            TODO: 펫과 자리 swap할때 경로가 꼬이는 듯한 현상 발견.
20210225 - 게임 QUit 기능 제작

          util.py 제작

          sphere of acid 추가
          > 아직 사망 시 폭발하는 것과 폭발 시 산성 피해를 입히는 부분이 제작안됨.

          폭발 액션 제작
          > 폭발 시 시야 바깥과 벽까지 뚫어버리는 버그 수정 필요
          > 아이템과 폭발이 상호작용하는 부분 추가 필요

          알 수 없는 이유로 화면 해상도에 오류가 발생함.
          프로그램 자체의 문제라기보다는 컴퓨터 설정 상의 문제로 추정되기에 일단은 무시함.

          tcod 라이브러리 버전을 업데이트함.

          TODO: 세미액터에도 flammable 추가해야함. 특히 문에 추가해야 함
20210307 - 폭발 관련 버그 수정.

          조작키 꾹 누르고있으면 화면 끊김 현상 발생하는 것 원인 찾음, 수정 완료
          > 처음엔 게임 내의 알고리즘 자체가 느려서 발생하는 문제인줄 알았으나, 원인은 화면 출력을 화면에 변화가 일어날 때마다 해주지 않는 경우가 있어서 였음
          > sdl/tcod 라이브러리와 관련된 문제로 추정되며(버그는 아님), 버튼을 꾹 누르고 있을 때 tcod.wait()가 여러 명령을 동시에 수집하기 때문임.
          -----------------------------------
          0.0019991397857666016 - handle_events() - <type='KEYDOWN', scancode=SCANCODE_KP_6, sym=K_KP_6, mod=KMOD_NUM, repeat=True>
          0.0010309219360351562 - sort_entities()
          0.05603432655334473 - handle_world()
          0.0 - handle_events() - <type='TEXTINPUT', text='6')
          0.0010001659393310547 - sort_entities()
          0.0020093917846679688 - handle_world()
          0.0029900074005126953 - handle_events() - <type='KEYDOWN', scancode=SCANCODE_KP_6, sym=K_KP_6, mod=KMOD_NUM, repeat=True>
          0.0010008811950683594 - sort_entities()
          0.04899787902832031 - handle_world()
          0.0 - handle_events() - <type='TEXTINPUT', text='6')
          0.0009996891021728516 - sort_entities()
          0.0020003318786621094 - handle_world()
          0.0019998550415039062 - handle_events() - <type='KEYDOWN', scancode=SCANCODE_KP_6, sym=K_KP_6, mod=KMOD_NUM, repeat=True>
          0.0009989738464355469 - sort_entities()
          0.020000934600830078 - handle_world()
          0.0 - handle_events() - <type='TEXTINPUT', text='6')
          0.000965118408203125 - sort_entities()
          0.0019648075103759766 - handle_world()
          0.0020003318786621094 - handle_events() - <type='KEYDOWN', scancode=SCANCODE_KP_6, sym=K_KP_6, mod=KMOD_NUM, repeat=True>
          0.0010004043579101562 - sort_entities()
          0.05803370475769043 - handle_world()
          0.0 - handle_events() - <type='TEXTINPUT', text='6')
          0.0 - sort_entities()
          0.0010378360748291016 - handle_world()
          0.0019996166229248047 - handle_events() - <type='KEYDOWN', scancode=SCANCODE_KP_6, sym=K_KP_6, mod=KMOD_NUM, repeat=True>
          0.00099945068359375 - sort_entities()
          0.053034305572509766 - handle_world()
          0.0 - handle_events() - <type='TEXTINPUT', text='6')
          0.0010030269622802734 - sort_entities()
          0.0020012855529785156 - handle_world()
          0.0029964447021484375 - handle_events() - <type='KEYDOWN', scancode=SCANCODE_KP_6, sym=K_KP_6, mod=KMOD_NUM, repeat=True>
          0.001001119613647461 - sort_entities()
          0.05903482437133789 - handle_world()
          0.0 - handle_events() - <type='TEXTINPUT', text='6')
          0.0009996891021728516 - sort_entities()
          0.002003192901611328 - handle_world()
          0.0019981861114501953 - handle_events() - <type='KEYDOWN', scancode=SCANCODE_KP_6, sym=K_KP_6, mod=KMOD_NUM, repeat=True>
          0.0010020732879638672 - sort_entities()
          0.06403422355651855 - handle_world()
          0.0 - handle_events() - <type='TEXTINPUT', text='6')
          0.0 - sort_entities()
          0.002000570297241211 - handle_world()
          0.0010221004486083984 - handle_events() - <type='KEYDOWN', scancode=SCANCODE_KP_6, sym=K_KP_6, mod=KMOD_NUM, repeat=True>
          0.0 - sort_entities()
          0.002001047134399414 - handle_world()
          0.0 - handle_events() - <type='TEXTINPUT', text='6')
          0.0009746551513671875 - sort_entities()
          0.001973867416381836 - handle_world()
          0.8393642902374268 - total turn
          0.0010251998901367188 - context rendering >> 이 부분을 보면 6번키 입력이 연달아 이루어지고 나서야 한번 context rendering이 일어나는 것을 볼 수 있음.
          >> 즉 실제로 게임은 한 턴당 0.06초 혹은 10fps 정도로 턴제 게임에는 충분한 속도로 렌더링이 가능함.
          >> 예전에 작성한 코드들 수정하는 등 더 성능을 개선시키면 프레임을 끌어올릴 수는 있겠지만 아직은 굳이 필요치 않다고 생각됨.
          ----------------------------------- 
          0.0009984970092773438 - handle_events() - <type='KEYDOWN', scancode=SCANCODE_KP_6, sym=K_KP_6, mod=KMOD_NUM, repeat=True>
          0.0 - sort_entities()
          0.0009987354278564453 - handle_world()
          0.0 - handle_events() - <type='TEXTINPUT', text='6')
          0.00099945068359375 - sort_entities()
          0.002000093460083008 - handle_world()
          0.023000717163085938 - total turn
          0.002034902572631836 - context rendering
          -----------------------------------
          0.0009996891021728516 - handle_events() - <type='KEYDOWN', scancode=SCANCODE_KP_6, sym=K_KP_6, mod=KMOD_NUM, repeat=True>
          0.0010426044464111328 - sort_entities()
          0.0020449161529541016 - handle_world()
          0.0 - handle_events() - <type='TEXTINPUT', text='6')
          0.0009644031524658203 - sort_entities()
          0.001964092254638672 - handle_world()
          0.028748750686645508 - total turn
          0.0019989013671875 - context rendering
          -----------------------------------
          0.001043081283569336 - handle_events() - <type='KEYDOWN', scancode=SCANCODE_KP_6, sym=K_KP_6, mod=KMOD_NUM, repeat=True>
          0.001009225845336914 - sort_entities()
          0.0010459423065185547 - handle_world()
          0.0 - handle_events() - <type='TEXTINPUT', text='6')
          0.0009992122650146484 - sort_entities()
          0.001997709274291992 - handle_world()
          0.03007030487060547 - total turn
          0.0009975433349609375 - context rendering
          -----------------------------------

          >>> 해결 완료. 이제 프레임이 낮아질 지언정 화면이 끊기는 현상은 없음.
20210310 - potion of telepathy 뼈대 제작.
            > 각종 메소드 추가

            몬스터가 시야 내에 들어오면 wake하는 부분 원리를 바꿀것.
            
            몬스터간의 전투시 발생하는 버그 > ai.vision이 없는데도 vision을 확인하려 할 때 발생 (원인불명, 간혹 한번씩 발생)
            Traceback (most recent call last):
            File "c:\Users\user\Desktop\Geophyte_tcod\ver28_identification\ver28\main.py", line 56, in main
              engine.handle_world(turn_pass=turn_pass)
            File "c:\Users\user\Desktop\Geophyte_tcod\ver28_identification\ver28\engine.py", line 110, in handle_world
              self.handle_enemy_turns()
            File "c:\Users\user\Desktop\Geophyte_tcod\ver28_identification\ver28\engine.py", line 133, in handle_enemy_turns
              entity.ai.perform()
            File "c:\Users\user\Desktop\Geophyte_tcod\ver28_identification\ver28\components\ai.py", line 90, in perform
              self.check_active()
            File "c:\Users\user\Desktop\Geophyte_tcod\ver28_identification\ver28\components\ai.py", line 71, in check_active
              if self.gamemap.visible[self.parent.x, self.parent.y] and self.vision[self.engine.player.x, self.engine.player.y]:
          TypeError: 'NoneType' object is not subscriptable
          >> 원인은 아마 regenerated된 몬스터의 vision이 초기화가 안된 상태라 그런 것 같음.
          >> 수정

          일부 메세지 로그가 액터의 위치에 관계없이 로그창에 표시되는 현상 발견.
          > ex. 보이지 않는 곳에서 다른 몬스터가 번개를 맞은 게 로그창에 뜸.
          > 어떤 종류의 메세지들에 이런 현상이 나타나는지를 기록해서 일괄적으로 해결해야 할듯함.

          f10키를 누르면 해당 층의 모든 몬스터를 activate하도록 디버그용 기능 제작.
20210314 - procgen의 room generation의 방 판정 방식을 slicing을 사용한 현 방법에서 
          조금 더 유동적인 방법으로 변경하려고 시도했지만 오히려 성능이 악화되는 모습을 보여 롤백함.

          procgen 관련 함수들 코드 정리, 반복 줄이고 더 작은 함수들로 분할
          
          <버그발견>
          scroll of tame 취소가 그냥 되는 경우 확인 >> 수정
          scroll of identify 취소 시 에러발생, 원인 불명
20210315 - prealpha로 브랜치 이동.
          폭발 범위가 맵 경계를 초과할 경우 폭발 자체가 무효화되는 버그 발견
          > 수정
          타이틀화면에 사진 추가할 수 있는 기능 추가, 타이틀 스크린 대폭 수정.
20210318 - actor_state의 각종 항목들을 python list에서 numpy array로 변경해보았으나, 오히려 퍼포먼스가 떨어지는 모습을 보여 다시 롤백함.
          > 소량의 데이터를 다룰 때에는 python list가 numpy보다 유리하기 때문인 것으로 추측됨.
          >> numpy를 사용하면 메모리야 어느 정도 줄일 수 있겠지만 performance차이가 너무 나서 롤백.

          카메라 전체를 특정 색으로 shifting하는 기능 추가하려 했으나, tile들의 rgb가 튜플이 아닌 specified된 numpy datatype으로 저장되어있어서 일단은 보류함.
          > util에 grayscale과 blueshift 함수 추가.
          
          telepathy 추가
          > 시야 일정 범위 (이 범위는 int값에 비례함) 내의 적대적인 액터들을 빨간색 물음표로, 그렇지 않은 액터를 하얀색 물음표로 렌더링.

          camera에 visuals 추가, visual.py추가 (Visual 오브젝트 추가)
          > 시각적인 용도 이외 아무런 용도가 없는 객체들로, 맵상의 위치(절대좌표)와 lifetime을 가짐.
          > camera.render()에서 렌더링됨.
          >> TODO: camera.render()에서 visual이 렌더링되자마자 바로 사라지는 문제 해결해야함. print되자마자 바로 refresh되는 듯함.

          engine.update_additional_vision() 제작
          > 이제 일반적인 시야 fov 업데이트 이외의 모든 시야 관련 효과는 여기서 처리됨.

          여러 액터들의 시체 제작

          ant부터 Floating Eye까지 액터들 완전히 마무리지음. (desc 추가, 시체 추가, 스텟 재조정, 난이도/rarity 재조정 등)

          edible에 can_cook 추가
          edible에 cook_bonus 추가
          > 조리 시 nutrition 상승할 수 있음

          edible에 섭취 시 발생 가능한 특수효과 추가
          > 조리 후 섭취 시 발생하는 효과, 그냥 먹으면 발생하는 효과, 항상 발생하는 효과 이렇게 세 카테고리로 분류함.
20210320 - main 함수에서 on_render()를 실행하는 과정에서 중대한 퍼포먼스 문제가 있었음을 발견, 수정함.
          > render을 매 이벤트의 실행마다 해주는 대신 매 게임루프 종료 후 해주는 방식으로 수정함.
          >> 20210322 : 수정 롤백, 화면 끊김 방지를 위해 불가피한 부분임.

          visual object 렌더링 관련 문제 해결중. 아직 미해결.
20210321 - visual object 관련 문제 해결... 상당히 어려웠음
          > 원인은 여러 가지가 있지만 main에서 engine.render()이 매 턴 호출되는 게 아니라는 점 때문이었음.
            처음에는 engine.render()이 매 게임 이벤트마다 호출되어서 이를 매 게임 루프마다 호출되는 것으로 변경해주었고,
            매 게임루프마다 호출되기 때문에 한 턴에 여러 차례 engine.render()이 호출 되는 경우가 발생해 이러한 경우 visual object의 lifetime(지속턴수)이 감소되지 않도록 하는 장치를 마련해야 했음.

          불과 세미액터의 상호작용 시스템 추가
          불이 엔티티와 상호작용하는 기존 구조 대거 변경
          > 이제 엔티티 내의 메소드 collide_with_fire()를 실행시켜 불과의 상호작용을 처리함.

          세미액터와 관련된 정보를 다루는 semiactor_info 추가.

          render에 get_names_at_location에 display_id 파라미터 추가 (디버그용 기능). 
          앞으로 마우스 위의 엔티티의 id(메모리)를 알고 싶다면 True로 설정해주면 됨.

          floating eye의 시체에 먹으면 telepathy 획득하도록 만듬.
20210322 - 이미지 대신 ttf파일을 타일셋으로 불러오는 기능 추가,tileset.ttf 추가
            > 한글화 가능!!!

            draw_thick_frame()을 util.py에 제작.

            TODO: color.gui_frame_bg를 플레이어 상태(ex.on fire -> 빨강색) 혹은 현재 플레이어가 있는 terrain에 의해 바뀌게 하면 가시적으로 상태를 나타낼 수 있을 듯함.

            타일셋 변경으로 인해 anim_graphic의 여러 그래픽 char 변경.
20210323 - 한글패치 완료

            불 세미액터의 rule.py 최적화 완료.

            actor_state에서 이미 상태이상이 있는 상태에서 또다시 중첩될 때 어떻게 판단해야 하는지 결정하는 역할을 하는 apply_xxxing 함수들 제작

            액터가 불에 붙었을 때 처음 접촉 시에만 인벤토리에 불이 붙는 게 아니라, 액터가 불이 붙어있는 한 계속 인벤토리의 아이템이 불 탈 위험에 노출되도록 변경.
20210324 - Config.JSON으로부터 컨픽을 읽어오도록 게임 시스템 변경.

          GUI 관련 대거 수정
          > 최대한 하드코딩된 수치 없이 GUI 전체가 서로의 크기에 맞춰 유동적으로 자리를 배치하도록 시스템을 보정함.
          > GUI 프레임(테두리)가 두겹씩 맞닿지 않도록 수정.

          ConfigException 제작

          디스플레이 관련 대거 수정
          > 화면 해상도 변경 (16px per tile에서 기본값 20px per tile로 변경)
          > 콘솔 크기 변경 100 * 60에서 96*54로 변경. 16:9 맞추기 위함.

          유저가 게임 내 설정을 변경할 수 있도록 옵션 시스템 추가
          > 디스플레이 설정부분 제작. (풀스크/창모드 결정, 해상도 조절)
20210325 - 크레딧 제작
20210326 - black jelly가 독성점액을 던질 때 이 독성 점액을 모아뒀다 원거리무기로 활용하는 플레이를 방지하고자 독성 점액을 썩도록 만듬.
          > 동시에 black jelly 몬스터가 가지고 있는 아이템은 썩지 않게 만듬. 그래야 탄약이 바닥나는 일 방지.

          AI에 attraction 추가를 위한 뼈대 제작중

          